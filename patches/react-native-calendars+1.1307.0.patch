diff --git a/node_modules/react-native-calendars/src/calendar/day/basic/style.js b/node_modules/react-native-calendars/src/calendar/day/basic/style.js
index edafbd3..5fd28d3 100644
--- a/node_modules/react-native-calendars/src/calendar/day/basic/style.js
+++ b/node_modules/react-native-calendars/src/calendar/day/basic/style.js
@@ -1,71 +1,74 @@
 import { StyleSheet } from 'react-native';
-import * as defaultStyle from '../../../style';
+
 import constants from '../../../commons/constants';
+import * as defaultStyle from '../../../style';
+
 export default function styleConstructor(theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        container: {
-            alignSelf: 'stretch',
-            alignItems: 'center'
-        },
-        base: {
-            width: 32,
-            height: 32,
-            alignItems: 'center'
-        },
-        text: {
-            marginTop: constants.isAndroid ? 4 : 6,
-            fontSize: appStyle.textDayFontSize,
-            fontFamily: appStyle.textDayFontFamily,
-            fontWeight: appStyle.textDayFontWeight,
-            color: appStyle.dayTextColor,
-            backgroundColor: 'rgba(255, 255, 255, 0)',
-            ...appStyle.textDayStyle
-        },
-        alignedText: {
-            marginTop: constants.isAndroid ? 4 : 6
-        },
-        selected: {
-            backgroundColor: appStyle.selectedDayBackgroundColor,
-            borderRadius: 16
-        },
-        today: {
-            backgroundColor: appStyle.todayBackgroundColor,
-            borderRadius: 16
-        },
-        todayText: {
-            color: appStyle.todayTextColor
-        },
-        selectedText: {
-            color: appStyle.selectedDayTextColor
-        },
-        disabledText: {
-            color: appStyle.textDisabledColor
-        },
-        inactiveText: {
-            color: appStyle.textInactiveColor
-        },
-        dot: {
-            width: 4,
-            height: 4,
-            marginTop: 1,
-            borderRadius: 2,
-            opacity: 0,
-            ...appStyle.dotStyle
-        },
-        visibleDot: {
-            opacity: 1,
-            backgroundColor: appStyle.dotColor
-        },
-        selectedDot: {
-            backgroundColor: appStyle.selectedDotColor
-        },
-        disabledDot: {
-            backgroundColor: appStyle.disabledDotColor || appStyle.dotColor
-        },
-        todayDot: {
-            backgroundColor: appStyle.todayDotColor || appStyle.dotColor
-        },
-        ...(theme['stylesheet.day.basic'] || {})
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    container: {
+      alignSelf: 'stretch',
+      alignItems: 'center',
+    },
+    base: {
+      width: 32,
+      height: 32,
+      alignItems: 'center',
+    },
+    text: {
+      marginTop: constants.isAndroid ? 4 : 6,
+      fontSize: appStyle.textDayFontSize,
+      fontFamily: appStyle.textDayFontFamily,
+      fontWeight: appStyle.textDayFontWeight,
+      color: appStyle.dayTextColor,
+      backgroundColor: 'rgba(255, 255, 255, 0)',
+      ...appStyle.textDayStyle,
+    },
+    alignedText: {
+      marginTop: constants.isAndroid ? 4 : 6,
+    },
+    selected: {
+      backgroundColor: appStyle.selectedDayBackgroundColor,
+      borderRadius: 16,
+    },
+    today: {
+      backgroundColor: appStyle.todayBackgroundColor,
+      borderRadius: 16,
+    },
+    todayText: {
+      color: appStyle.todayTextColor,
+    },
+    selectedText: {
+      color: appStyle.selectedDayTextColor,
+    },
+    disabledText: {
+      color: appStyle.textDisabledColor,
+    },
+    inactiveText: {
+      color: appStyle.textInactiveColor,
+    },
+    dot: {
+      width: 4,
+      height: 4,
+      marginTop: 1,
+      borderRadius: 2,
+      opacity: 0,
+      ...appStyle.dotStyle,
+    },
+    visibleDot: {
+      opacity: 1,
+
+      backgroundColor: appStyle.dotColor,
+    },
+    selectedDot: {
+      backgroundColor: appStyle.selectedDotColor,
+    },
+    disabledDot: {
+      backgroundColor: appStyle.disabledDotColor || appStyle.dotColor,
+    },
+    todayDot: {
+      backgroundColor: appStyle.todayDotColor || appStyle.dotColor,
+    },
+    ...(theme['stylesheet.day.basic'] || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/calendar/day/dot/style.js b/node_modules/react-native-calendars/src/calendar/day/dot/style.js
index 69802cc..350d7b9 100644
--- a/node_modules/react-native-calendars/src/calendar/day/dot/style.js
+++ b/node_modules/react-native-calendars/src/calendar/day/dot/style.js
@@ -1,33 +1,35 @@
 import { StyleSheet } from 'react-native';
+
 import * as defaultStyle from '../../../style';
+
 export default function styleConstructor(theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        dot: {
-            width: 4,
-            height: 4,
-            marginTop: 1,
-            marginHorizontal: 1,
-            borderRadius: 2,
-            opacity: 0,
-            ...appStyle.dotStyle
-        },
-        visibleDot: {
-            opacity: 1,
-            backgroundColor: appStyle.dotColor
-        },
-        selectedDot: {
-            backgroundColor: appStyle.selectedDotColor
-        },
-        disabledDot: {
-            backgroundColor: appStyle.disabledDotColor || appStyle.dotColor
-        },
-        inactiveDot: {
-            backgroundColor: appStyle.inactiveDotColor || appStyle.dotColor
-        },
-        todayDot: {
-            backgroundColor: appStyle.todayDotColor || appStyle.dotColor
-        },
-        ...(theme['stylesheet.dot'] || {})
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    dot: {
+      width: 8,
+      height: 8,
+      marginTop: 8,
+      marginHorizontal: 1,
+      borderRadius: 8,
+      opacity: 0,
+      ...appStyle.dotStyle,
+    },
+    visibleDot: {
+      opacity: 1,
+      backgroundColor: appStyle.dotColor,
+    },
+    selectedDot: {
+      backgroundColor: '#BFFF41',
+    },
+    disabledDot: {
+      backgroundColor: appStyle.disabledDotColor || appStyle.dotColor,
+    },
+    inactiveDot: {
+      backgroundColor: appStyle.inactiveDotColor || appStyle.dotColor,
+    },
+    todayDot: {
+      backgroundColor: appStyle.todayDotColor || appStyle.dotColor,
+    },
+    ...(theme['stylesheet.dot'] || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/calendar/day/marking/index.js b/node_modules/react-native-calendars/src/calendar/day/marking/index.js
index 338c1e5..dd6fd23 100644
--- a/node_modules/react-native-calendars/src/calendar/day/marking/index.js
+++ b/node_modules/react-native-calendars/src/calendar/day/marking/index.js
@@ -1,73 +1,77 @@
-import filter from 'lodash/filter';
 import React, { useRef } from 'react';
 import { View } from 'react-native';
-import { extractDotProps } from '../../../componentUpdater';
+
+import filter from 'lodash/filter';
+
 import styleConstructor from './style';
+
+import { extractDotProps } from '../../../componentUpdater';
 import Dot from '../dot';
+
 export var Markings;
 (function (Markings) {
-    Markings["DOT"] = "dot";
-    Markings["MULTI_DOT"] = "multi-dot";
-    Markings["PERIOD"] = "period";
-    Markings["MULTI_PERIOD"] = "multi-period";
-    Markings["CUSTOM"] = "custom";
+  Markings['DOT'] = 'dot';
+  Markings['MULTI_DOT'] = 'multi-dot';
+  Markings['PERIOD'] = 'period';
+  Markings['MULTI_PERIOD'] = 'multi-period';
+  Markings['CUSTOM'] = 'custom';
 })(Markings || (Markings = {}));
 const Marking = (props) => {
-    const { theme, type, dots, periods, selected, dotColor } = props;
-    const style = useRef(styleConstructor(theme));
-    const getItems = (items) => {
-        if (items && Array.isArray(items) && items.length > 0) {
-            // Filter out items so that we process only those which have color property
-            const validItems = filter(items, function (o) {
-                return o.color;
-            });
-            return validItems.map((item, index) => {
-                return type === Markings.MULTI_DOT ? renderDot(index, item) : renderPeriod(index, item);
-            });
-        }
-    };
-    const renderMarkingByType = () => {
-        switch (type) {
-            case Markings.MULTI_DOT:
-                return renderMultiMarkings(style.current.dots, dots);
-            case Markings.MULTI_PERIOD:
-                return renderMultiMarkings(style.current.periods, periods);
-            default:
-                return renderDot();
-        }
-    };
-    const renderMultiMarkings = (containerStyle, items) => {
-        return <View style={containerStyle}>{getItems(items)}</View>;
-    };
-    const renderPeriod = (index, item) => {
-        const { color, startingDay, endingDay } = item;
-        const styles = [
-            style.current.period,
-            {
-                backgroundColor: color
-            }
-        ];
-        if (startingDay) {
-            styles.push(style.current.startingDay);
-        }
-        if (endingDay) {
-            styles.push(style.current.endingDay);
-        }
-        return <View key={index} style={styles}/>;
-    };
-    const renderDot = (index, item) => {
-        const dotProps = extractDotProps(props);
-        let key = index;
-        let color = dotColor;
-        if (item) {
-            if (item.key) {
-                key = item.key;
-            }
-            color = selected && item.selectedDotColor ? item.selectedDotColor : item.color;
-        }
-        return <Dot {...dotProps} key={key} color={color}/>;
-    };
-    return renderMarkingByType();
+  const { theme, type, dots, periods, selected, dotColor } = props;
+  const style = useRef(styleConstructor(theme));
+  const getItems = (items) => {
+    if (items && Array.isArray(items) && items.length > 0) {
+      // Filter out items so that we process only those which have color property
+      const validItems = filter(items, function (o) {
+        return o.color;
+      });
+      return validItems.map((item, index) => {
+        return type === Markings.MULTI_DOT ? renderDot(index, item) : renderPeriod(index, item);
+      });
+    }
+  };
+  const renderMarkingByType = () => {
+    switch (type) {
+      case Markings.MULTI_DOT:
+        return renderMultiMarkings(style.current.dots, dots);
+      case Markings.MULTI_PERIOD:
+        return renderMultiMarkings(style.current.periods, periods);
+      default:
+        return renderDot();
+    }
+  };
+  const renderMultiMarkings = (containerStyle, items) => {
+    return <View style={containerStyle}>{getItems(items)}</View>;
+  };
+  const renderPeriod = (index, item) => {
+    const { color, startingDay, endingDay } = item;
+    const styles = [
+      style.current.period,
+      {
+        backgroundColor: color,
+      },
+    ];
+    if (startingDay) {
+      styles.push(style.current.startingDay);
+    }
+    if (endingDay) {
+      styles.push(style.current.endingDay);
+    }
+    return <View key={index} style={styles} />;
+  };
+  const renderDot = (index, item) => {
+    const dotProps = extractDotProps(props);
+    let key = index;
+    let color = dotColor;
+    if (item) {
+      if (item.key) {
+        key = item.key;
+      }
+      color = selected && item.selectedDotColor ? item.selectedDotColor : item.color;
+    }
+    return <Dot {...dotProps} key={key} color={color} />;
+  };
+  return renderMarkingByType();
 };
 export default Marking;
 Marking.displayName = 'Marking';
diff --git a/node_modules/react-native-calendars/src/calendar/day/marking/style.js b/node_modules/react-native-calendars/src/calendar/day/marking/style.js
index ad10e5c..78ffa3e 100644
--- a/node_modules/react-native-calendars/src/calendar/day/marking/style.js
+++ b/node_modules/react-native-calendars/src/calendar/day/marking/style.js
@@ -1,29 +1,31 @@
 import { StyleSheet } from 'react-native';
+
 import * as defaultStyle from '../../style';
+
 export default function styleConstructor(theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        dots: {
-            flexDirection: 'row'
-        },
-        periods: {
-            alignSelf: 'stretch'
-        },
-        period: {
-            height: 4,
-            marginVertical: 1,
-            backgroundColor: appStyle.dotColor
-        },
-        startingDay: {
-            borderTopLeftRadius: 2,
-            borderBottomLeftRadius: 2,
-            marginLeft: 4
-        },
-        endingDay: {
-            borderTopRightRadius: 2,
-            borderBottomRightRadius: 2,
-            marginRight: 4
-        },
-        ...(theme['stylesheet.marking'] || {})
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    dots: {
+      flexDirection: 'row',
+    },
+    periods: {
+      alignSelf: 'stretch',
+    },
+    period: {
+      height: 4,
+      marginVertical: 1,
+      backgroundColor: appStyle.dotColor,
+    },
+    startingDay: {
+      borderTopLeftRadius: 2,
+      borderBottomLeftRadius: 2,
+      marginLeft: 4,
+    },
+    endingDay: {
+      borderTopRightRadius: 2,
+      borderBottomRightRadius: 2,
+      marginRight: 4,
+    },
+    ...(theme['stylesheet.marking'] || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/calendar/header/index.js b/node_modules/react-native-calendars/src/calendar/header/index.js
index bd75364..51a839f 100644
--- a/node_modules/react-native-calendars/src/calendar/header/index.js
+++ b/node_modules/react-native-calendars/src/calendar/header/index.js
@@ -1,129 +1,196 @@
+import React, { Fragment, forwardRef, useCallback, useImperativeHandle, useMemo, useRef } from 'react';
+import { ActivityIndicator, Image, Platform, Text, TouchableOpacity, View } from 'react-native';
+
 import includes from 'lodash/includes';
 import XDate from 'xdate';
-import React, { Fragment, useCallback, useMemo, forwardRef, useImperativeHandle, useRef } from 'react';
-import { ActivityIndicator, Platform, View, Text, TouchableOpacity, Image } from 'react-native';
-import { formatNumbers, weekDayNames } from '../../dateutils';
+
 import styleConstructor from './style';
+
+import { formatNumbers, weekDayNames } from '../../dateutils';
+
 const accessibilityActions = [
-    { name: 'increment', label: 'increment' },
-    { name: 'decrement', label: 'decrement' }
+  { name: 'increment', label: 'increment' },
+  { name: 'decrement', label: 'decrement' },
 ];
 const CalendarHeader = forwardRef((props, ref) => {
-    const { theme, style: propsStyle, addMonth: propsAddMonth, month, monthFormat, firstDay, hideDayNames, showWeekNumbers, hideArrows, renderArrow, onPressArrowLeft, onPressArrowRight, arrowsHitSlop = 20, disableArrowLeft, disableArrowRight, disabledDaysIndexes, displayLoadingIndicator, customHeaderTitle, renderHeader, webAriaLevel, testID, accessibilityElementsHidden, importantForAccessibility, numberOfDays, current = '', timelineLeftInset } = props;
-    const numberOfDaysCondition = useMemo(() => {
-        return numberOfDays && numberOfDays > 1;
-    }, [numberOfDays]);
-    const style = useRef(styleConstructor(theme));
-    const headerStyle = useMemo(() => {
-        return [style.current.header, numberOfDaysCondition ? style.current.partialHeader : undefined];
-    }, [numberOfDaysCondition]);
-    const partialWeekStyle = useMemo(() => {
-        return [style.current.partialWeek, { paddingLeft: timelineLeftInset }];
-    }, [timelineLeftInset]);
-    const dayNamesStyle = useMemo(() => {
-        return [style.current.week, numberOfDaysCondition ? partialWeekStyle : undefined];
-    }, [numberOfDaysCondition, partialWeekStyle]);
-    const hitSlop = useMemo(() => typeof arrowsHitSlop === 'number'
+  const {
+    theme,
+    style: propsStyle,
+    addMonth: propsAddMonth,
+    month,
+    monthFormat,
+    firstDay,
+    hideDayNames,
+    showWeekNumbers,
+    hideArrows,
+    renderArrow,
+    onPressArrowLeft,
+    onPressArrowRight,
+    arrowsHitSlop = 20,
+    disableArrowLeft,
+    disableArrowRight,
+    disabledDaysIndexes,
+    displayLoadingIndicator,
+    customHeaderTitle,
+    renderHeader,
+    webAriaLevel,
+    testID,
+    accessibilityElementsHidden,
+    importantForAccessibility,
+    numberOfDays,
+    current = '',
+    timelineLeftInset,
+  } = props;
+  const numberOfDaysCondition = useMemo(() => {
+    return numberOfDays && numberOfDays > 1;
+  }, [numberOfDays]);
+  const style = useRef(styleConstructor(theme));
+  const headerStyle = useMemo(() => {
+    return [style.current.header, numberOfDaysCondition ? style.current.partialHeader : undefined];
+  }, [numberOfDaysCondition]);
+  const partialWeekStyle = useMemo(() => {
+    return [style.current.partialWeek, { paddingLeft: timelineLeftInset }];
+  }, [timelineLeftInset]);
+  const dayNamesStyle = useMemo(() => {
+    return [style.current.week, numberOfDaysCondition ? partialWeekStyle : undefined];
+  }, [numberOfDaysCondition, partialWeekStyle]);
+  const hitSlop = useMemo(
+    () =>
+      typeof arrowsHitSlop === 'number'
         ? { top: arrowsHitSlop, left: arrowsHitSlop, bottom: arrowsHitSlop, right: arrowsHitSlop }
-        : arrowsHitSlop, [arrowsHitSlop]);
-    useImperativeHandle(ref, () => ({
-        onPressLeft,
-        onPressRight
-    }));
-    const addMonth = useCallback(() => {
-        propsAddMonth?.(1);
-    }, [propsAddMonth]);
-    const subtractMonth = useCallback(() => {
-        propsAddMonth?.(-1);
-    }, [propsAddMonth]);
-    const onPressLeft = useCallback(() => {
-        if (typeof onPressArrowLeft === 'function') {
-            return onPressArrowLeft(subtractMonth, month);
-        }
-        return subtractMonth();
-    }, [onPressArrowLeft, subtractMonth, month]);
-    const onPressRight = useCallback(() => {
-        if (typeof onPressArrowRight === 'function') {
-            return onPressArrowRight(addMonth, month);
-        }
-        return addMonth();
-    }, [onPressArrowRight, addMonth, month]);
-    const onAccessibilityAction = useCallback((event) => {
-        switch (event.nativeEvent.actionName) {
-            case 'decrement':
-                onPressLeft();
-                break;
-            case 'increment':
-                onPressRight();
-                break;
-            default:
-                break;
-        }
-    }, [onPressLeft, onPressRight]);
-    const renderWeekDays = useMemo(() => {
-        const dayOfTheWeek = new XDate(current).getDay();
-        const weekDaysNames = numberOfDaysCondition ? weekDayNames(dayOfTheWeek) : weekDayNames(firstDay);
-        const dayNames = numberOfDaysCondition ? weekDaysNames.slice(0, numberOfDays) : weekDaysNames;
-        return dayNames.map((day, index) => {
-            const dayStyle = [style.current.dayHeader];
-            if (includes(disabledDaysIndexes, index)) {
-                dayStyle.push(style.current.disabledDayHeader);
-            }
-            const dayTextAtIndex = `dayTextAtIndex${index}`;
-            if (style.current[dayTextAtIndex]) {
-                dayStyle.push(style.current[dayTextAtIndex]);
-            }
-            return (<Text allowFontScaling={false} key={index} style={dayStyle} numberOfLines={1} accessibilityLabel={''}>
+        : arrowsHitSlop,
+    [arrowsHitSlop],
+  );
+  useImperativeHandle(ref, () => ({
+    onPressLeft,
+    onPressRight,
+  }));
+  const addMonth = useCallback(() => {
+    propsAddMonth?.(1);
+  }, [propsAddMonth]);
+  const subtractMonth = useCallback(() => {
+    propsAddMonth?.(-1);
+  }, [propsAddMonth]);
+  const onPressLeft = useCallback(() => {
+    if (typeof onPressArrowLeft === 'function') {
+      return onPressArrowLeft(subtractMonth, month);
+    }
+    return subtractMonth();
+  }, [onPressArrowLeft, subtractMonth, month]);
+  const onPressRight = useCallback(() => {
+    if (typeof onPressArrowRight === 'function') {
+      return onPressArrowRight(addMonth, month);
+    }
+    return addMonth();
+  }, [onPressArrowRight, addMonth, month]);
+  const onAccessibilityAction = useCallback(
+    (event) => {
+      switch (event.nativeEvent.actionName) {
+        case 'decrement':
+          onPressLeft();
+          break;
+        case 'increment':
+          onPressRight();
+          break;
+        default:
+          break;
+      }
+    },
+    [onPressLeft, onPressRight],
+  );
+  const renderWeekDays = useMemo(() => {
+    const dayOfTheWeek = new XDate(current).getDay();
+    const weekDaysNames = numberOfDaysCondition ? weekDayNames(dayOfTheWeek) : weekDayNames(firstDay);
+    const dayNames = numberOfDaysCondition ? weekDaysNames.slice(0, numberOfDays) : weekDaysNames;
+    return dayNames.map((day, index) => {
+      const dayStyle = [style.current.dayHeader];
+      if (includes(disabledDaysIndexes, index)) {
+        dayStyle.push(style.current.disabledDayHeader);
+      }
+      const dayTextAtIndex = `dayTextAtIndex${index}`;
+      if (style.current[dayTextAtIndex]) {
+        dayStyle.push(style.current[dayTextAtIndex]);
+      }
+      return (
+        <Text allowFontScaling={false} key={index} style={dayStyle} numberOfLines={1} accessibilityLabel={''}>
           {day}
-        </Text>);
-        });
-    }, [firstDay, current, numberOfDaysCondition, numberOfDays, disabledDaysIndexes]);
-    const _renderHeader = () => {
-        const webProps = Platform.OS === 'web' ? { 'aria-level': webAriaLevel } : {};
-        if (renderHeader) {
-            return renderHeader(month);
-        }
-        if (customHeaderTitle) {
-            return customHeaderTitle;
-        }
-        return (<Fragment>
+        </Text>
+      );
+    });
+  }, [firstDay, current, numberOfDaysCondition, numberOfDays, disabledDaysIndexes]);
+  const _renderHeader = () => {
+    const webProps = Platform.OS === 'web' ? { 'aria-level': webAriaLevel } : {};
+    if (renderHeader) {
+      return renderHeader(month);
+    }
+    if (customHeaderTitle) {
+      return customHeaderTitle;
+    }
+    return (
+      <Fragment>
         <Text allowFontScaling={false} style={style.current.monthText} testID={`${testID}.title`} {...webProps}>
           {formatNumbers(month?.toString(monthFormat))}
         </Text>
-      </Fragment>);
-    };
-    const _renderArrow = (direction) => {
-        if (hideArrows) {
-            return <View />;
-        }
-        const isLeft = direction === 'left';
-        const arrowId = isLeft ? 'leftArrow' : 'rightArrow';
-        const shouldDisable = isLeft ? disableArrowLeft : disableArrowRight;
-        const onPress = !shouldDisable ? isLeft ? onPressLeft : onPressRight : undefined;
-        const imageSource = isLeft ? require('../img/previous.png') : require('../img/next.png');
-        const renderArrowDirection = isLeft ? 'left' : 'right';
-        return (<TouchableOpacity onPress={onPress} disabled={shouldDisable} style={style.current.arrow} hitSlop={hitSlop} testID={`${testID}.${arrowId}`}>
-        {renderArrow ? (renderArrow(renderArrowDirection)) : (<Image source={imageSource} style={shouldDisable ? style.current.disabledArrowImage : style.current.arrowImage}/>)}
-      </TouchableOpacity>);
-    };
-    const renderIndicator = () => {
-        if (displayLoadingIndicator) {
-            return (<ActivityIndicator color={theme?.indicatorColor} testID={`${testID}.loader`}/>);
-        }
-    };
-    const renderWeekNumbersSpace = () => {
-        return showWeekNumbers && <View style={style.current.dayHeader}/>;
-    };
-    const renderDayNames = () => {
-        if (!hideDayNames) {
-            return (<View style={dayNamesStyle} testID={`${testID}.dayNames`}>
+      </Fragment>
+    );
+  };
+  const _renderArrow = (direction) => {
+    if (hideArrows) {
+      return <View />;
+    }
+    const isLeft = direction === 'left';
+    const arrowId = isLeft ? 'leftArrow' : 'rightArrow';
+    const shouldDisable = isLeft ? disableArrowLeft : disableArrowRight;
+    const onPress = !shouldDisable ? (isLeft ? onPressLeft : onPressRight) : undefined;
+    const imageSource = isLeft ? require('../img/previous.png') : require('../img/next.png');
+    const renderArrowDirection = isLeft ? 'left' : 'right';
+    return (
+      <TouchableOpacity
+        onPress={onPress}
+        disabled={shouldDisable}
+        style={style.current.arrow}
+        hitSlop={hitSlop}
+        testID={`${testID}.${arrowId}`}
+      >
+        {renderArrow ? (
+          renderArrow(renderArrowDirection)
+        ) : (
+          <Image
+            source={imageSource}
+            style={shouldDisable ? style.current.disabledArrowImage : style.current.arrowImage}
+          />
+        )}
+      </TouchableOpacity>
+    );
+  };
+  const renderIndicator = () => {
+    if (displayLoadingIndicator) {
+      return <ActivityIndicator color={theme?.indicatorColor} testID={`${testID}.loader`} />;
+    }
+  };
+  const renderWeekNumbersSpace = () => {
+    return showWeekNumbers && <View style={style.current.dayHeader} />;
+  };
+  const renderDayNames = () => {
+    if (!hideDayNames) {
+      return (
+        <View style={dayNamesStyle} testID={`${testID}.dayNames`}>
           {renderWeekNumbersSpace()}
           {renderWeekDays}
-        </View>);
-        }
-    };
-    return (<View testID={testID} style={propsStyle} accessible accessibilityRole={'adjustable'} accessibilityActions={accessibilityActions} onAccessibilityAction={onAccessibilityAction} accessibilityElementsHidden={accessibilityElementsHidden} // iOS
-     importantForAccessibility={importantForAccessibility} // Android
+        </View>
+      );
+    }
+  };
+  return (
+    <View
+      testID={testID}
+      style={propsStyle}
+      accessible
+      accessibilityRole={'adjustable'}
+      accessibilityActions={accessibilityActions}
+      onAccessibilityAction={onAccessibilityAction}
+      accessibilityElementsHidden={accessibilityElementsHidden} // iOS
+      importantForAccessibility={importantForAccessibility} // Android
     >
       <View style={headerStyle}>
         {_renderArrow('left')}
@@ -134,12 +201,13 @@ const CalendarHeader = forwardRef((props, ref) => {
         {_renderArrow('right')}
       </View>
       {renderDayNames()}
-    </View>);
+    </View>
+  );
 });
 export default CalendarHeader;
 CalendarHeader.displayName = 'CalendarHeader';
 CalendarHeader.defaultProps = {
-    monthFormat: 'MMMM yyyy',
-    webAriaLevel: 1,
-    arrowsHitSlop: 20
+  monthFormat: 'MMMM',
+  webAriaLevel: 1,
+  arrowsHitSlop: 20,
 };
diff --git a/node_modules/react-native-calendars/src/calendar/header/style.js b/node_modules/react-native-calendars/src/calendar/header/style.js
index 2b6e01c..220f465 100644
--- a/node_modules/react-native-calendars/src/calendar/header/style.js
+++ b/node_modules/react-native-calendars/src/calendar/header/style.js
@@ -1,70 +1,74 @@
-import { StyleSheet, Platform } from 'react-native';
-import * as defaultStyle from '../../style';
+import { Platform, StyleSheet } from 'react-native';
+
 import constants from '../../commons/constants';
+import * as defaultStyle from '../../style';
+
 export default function (theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    const rtlStyle = constants.isRTL ? { transform: [{ scaleX: -1 }] } : undefined;
-    return StyleSheet.create({
-        header: {
-            flexDirection: 'row',
-            justifyContent: 'space-between',
-            paddingLeft: 10,
-            paddingRight: 10,
-            marginTop: 6,
-            alignItems: 'center',
-        },
-        partialHeader: {
-            paddingHorizontal: 15
-        },
-        headerContainer: {
-            flexDirection: 'row'
-        },
-        monthText: {
-            fontSize: appStyle.textMonthFontSize,
-            fontFamily: appStyle.textMonthFontFamily,
-            fontWeight: appStyle.textMonthFontWeight,
-            color: appStyle.monthTextColor,
-            margin: 10
-        },
-        arrow: {
-            padding: 10,
-            ...appStyle.arrowStyle
-        },
-        arrowImage: {
-            ...rtlStyle,
-            tintColor: appStyle.arrowColor,
-            ...Platform.select({
-                web: {
-                    width: appStyle.arrowWidth,
-                    height: appStyle.arrowHeight
-                }
-            })
-        },
-        disabledArrowImage: {
-            ...rtlStyle,
-            tintColor: appStyle.disabledArrowColor
-        },
-        week: {
-            marginTop: 7,
-            flexDirection: 'row',
-            justifyContent: 'space-around',
-        },
-        partialWeek: {
-            paddingRight: 0
-        },
-        dayHeader: {
-            marginTop: 2,
-            marginBottom: 7,
-            width: 32,
-            textAlign: 'center',
-            fontSize: appStyle.textDayHeaderFontSize,
-            fontFamily: appStyle.textDayHeaderFontFamily,
-            fontWeight: appStyle.textDayHeaderFontWeight,
-            color: appStyle.textSectionTitleColor
-        },
-        disabledDayHeader: {
-            color: appStyle.textSectionTitleDisabledColor
+  const appStyle = { ...defaultStyle, ...theme };
+  const rtlStyle = constants.isRTL ? { transform: [{ scaleX: -1 }] } : undefined;
+  return StyleSheet.create({
+    header: {
+      flexDirection: 'row',
+      justifyContent: 'space-between',
+      paddingLeft: 10,
+      paddingRight: 10,
+      marginTop: 6,
+      alignItems: 'center',
+    },
+    partialHeader: {
+      paddingHorizontal: 15,
+    },
+    headerContainer: {
+      flexDirection: 'row',
+    },
+    monthText: {
+      fontSize: appStyle.textMonthFontSize,
+      fontFamily: appStyle.textMonthFontFamily,
+      fontWeight: appStyle.textMonthFontWeight,
+      color: appStyle.monthTextColor,
+      flex: 1,
+      textAlign: 'right',
+      margin: 10,
+    },
+    arrow: {
+      padding: 10,
+      ...appStyle.arrowStyle,
+    },
+    arrowImage: {
+      ...rtlStyle,
+      tintColor: appStyle.arrowColor,
+      ...Platform.select({
+        web: {
+          width: appStyle.arrowWidth,
+          height: appStyle.arrowHeight,
         },
-        ...(theme['stylesheet.calendar.header'] || {})
-    });
+      }),
+    },
+    disabledArrowImage: {
+      ...rtlStyle,
+      tintColor: appStyle.disabledArrowColor,
+    },
+    week: {
+      marginTop: 7,
+      flexDirection: 'row',
+      justifyContent: 'space-around',
+    },
+    partialWeek: {
+      paddingRight: 0,
+    },
+    dayHeader: {
+      marginTop: 2,
+      marginBottom: 7,
+      width: 32,
+      textAlign: 'center',
+      fontSize: appStyle.textDayHeaderFontSize,
+      fontFamily: appStyle.textDayHeaderFontFamily,
+      fontWeight: appStyle.textDayHeaderFontWeight,
+      color: appStyle.textSectionTitleColor,
+    },
+    disabledDayHeader: {
+      color: appStyle.textSectionTitleDisabledColor,
+    },
+    ...(theme['stylesheet.calendar.header'] || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/calendar/index.js b/node_modules/react-native-calendars/src/calendar/index.js
index 6f46e8a..303bb40 100644
--- a/node_modules/react-native-calendars/src/calendar/index.js
+++ b/node_modules/react-native-calendars/src/calendar/index.js
@@ -1,188 +1,270 @@
-import PropTypes from 'prop-types';
-import XDate from 'xdate';
-import isEmpty from 'lodash/isEmpty';
-import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';
+import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
 import { View } from 'react-native';
 // @ts-expect-error
 import GestureRecognizer, { swipeDirections } from 'react-native-swipe-gestures';
+
+import isEmpty from 'lodash/isEmpty';
+import PropTypes from 'prop-types';
+import XDate from 'xdate';
+
+import BasicDay from './day/basic';
+import Day from './day/index';
+import CalendarHeader from './header';
+import styleConstructor from './style';
+
 import constants from '../commons/constants';
-import { page, isGTE, isLTE, sameMonth } from '../dateutils';
-import { xdateToData, parseDate, toMarkingFormat } from '../interface';
+import { extractDayProps, extractHeaderProps } from '../componentUpdater';
+import { isGTE, isLTE, page, sameMonth } from '../dateutils';
 import { getState } from '../day-state-manager';
-import { extractHeaderProps, extractDayProps } from '../componentUpdater';
 import { useDidUpdate } from '../hooks';
-import styleConstructor from './style';
-import CalendarHeader from './header';
-import Day from './day/index';
-import BasicDay from './day/basic';
+import { parseDate, toMarkingFormat, xdateToData } from '../interface';
+
 /**
  * @description: Calendar component
  * @example: https://github.com/wix/react-native-calendars/blob/master/example/src/screens/calendars.js
  * @gif: https://github.com/wix/react-native-calendars/blob/master/demo/assets/calendar.gif
  */
 const Calendar = (props) => {
-    const { initialDate, current, theme, markedDates, minDate, maxDate, allowSelectionOutOfRange, onDayPress, onDayLongPress, onMonthChange, onVisibleMonthsChange, disableMonthChange, enableSwipeMonths, hideExtraDays, firstDay, showSixWeeks, displayLoadingIndicator, customHeader, headerStyle, accessibilityElementsHidden, importantForAccessibility, testID, style: propsStyle } = props;
-    const [currentMonth, setCurrentMonth] = useState(current || initialDate ? parseDate(current || initialDate) : new XDate());
-    const style = useRef(styleConstructor(theme));
-    const header = useRef();
-    const weekNumberMarking = useRef({ disabled: true, disableTouchEvent: true });
-    useEffect(() => {
-        if (initialDate) {
-            setCurrentMonth(parseDate(initialDate));
-        }
-    }, [initialDate]);
-    useDidUpdate(() => {
-        const _currentMonth = currentMonth.clone();
-        onMonthChange?.(xdateToData(_currentMonth));
-        onVisibleMonthsChange?.([xdateToData(_currentMonth)]);
-    }, [currentMonth]);
-    const updateMonth = useCallback((newMonth) => {
-        if (sameMonth(newMonth, currentMonth)) {
-            return;
+  const {
+    initialDate,
+    current,
+    theme,
+    markedDates,
+    minDate,
+    maxDate,
+    allowSelectionOutOfRange,
+    onDayPress,
+    onDayLongPress,
+    onMonthChange,
+    onVisibleMonthsChange,
+    disableMonthChange,
+    enableSwipeMonths,
+    hideExtraDays,
+    firstDay,
+    showSixWeeks,
+    displayLoadingIndicator,
+    customHeader,
+    headerStyle,
+    accessibilityElementsHidden,
+    importantForAccessibility,
+    testID,
+    style: propsStyle,
+  } = props;
+  const [currentMonth, setCurrentMonth] = useState(
+    current || initialDate ? parseDate(current || initialDate) : new XDate(),
+  );
+  const style = useRef(styleConstructor(theme));
+  const header = useRef();
+  const weekNumberMarking = useRef({ disabled: true, disableTouchEvent: true });
+  useEffect(() => {
+    if (initialDate) {
+      setCurrentMonth(parseDate(initialDate));
+    }
+  }, [initialDate]);
+  useDidUpdate(() => {
+    const _currentMonth = currentMonth.clone();
+    onMonthChange?.(xdateToData(_currentMonth));
+    onVisibleMonthsChange?.([xdateToData(_currentMonth)]);
+  }, [currentMonth]);
+  const updateMonth = useCallback(
+    (newMonth) => {
+      if (sameMonth(newMonth, currentMonth)) {
+        return;
+      }
+      setCurrentMonth(newMonth);
+    },
+    [currentMonth],
+  );
+  const addMonth = useCallback(
+    (count) => {
+      const newMonth = currentMonth.clone().addMonths(count, true);
+      updateMonth(newMonth);
+    },
+    [currentMonth, updateMonth],
+  );
+  const handleDayInteraction = useCallback(
+    (date, interaction) => {
+      const day = new XDate(date.dateString);
+      if (
+        allowSelectionOutOfRange ||
+        (!(minDate && !isGTE(day, new XDate(minDate))) && !(maxDate && !isLTE(day, new XDate(maxDate))))
+      ) {
+        if (!disableMonthChange) {
+          updateMonth(day);
         }
-        setCurrentMonth(newMonth);
-    }, [currentMonth]);
-    const addMonth = useCallback((count) => {
-        const newMonth = currentMonth.clone().addMonths(count, true);
-        updateMonth(newMonth);
-    }, [currentMonth, updateMonth]);
-    const handleDayInteraction = useCallback((date, interaction) => {
-        const day = new XDate(date.dateString);
-        if (allowSelectionOutOfRange || !(minDate && !isGTE(day, new XDate(minDate))) && !(maxDate && !isLTE(day, new XDate(maxDate)))) {
-            if (!disableMonthChange) {
-                updateMonth(day);
-            }
-            if (interaction) {
-                interaction(date);
-            }
+        if (interaction) {
+          interaction(date);
         }
-    }, [minDate, maxDate, allowSelectionOutOfRange, disableMonthChange, updateMonth]);
-    const _onDayPress = useCallback((date) => {
-        if (date)
-            handleDayInteraction(date, onDayPress);
-    }, [handleDayInteraction, onDayPress]);
-    const onLongPressDay = useCallback((date) => {
-        if (date)
-            handleDayInteraction(date, onDayLongPress);
-    }, [handleDayInteraction, onDayLongPress]);
-    const onSwipeLeft = useCallback(() => {
-        // @ts-expect-error
-        header.current?.onPressRight();
-    }, [header]);
-    const onSwipeRight = useCallback(() => {
-        // @ts-expect-error
-        header.current?.onPressLeft();
-    }, [header]);
-    const onSwipe = useCallback((gestureName) => {
-        const { SWIPE_UP, SWIPE_DOWN, SWIPE_LEFT, SWIPE_RIGHT } = swipeDirections;
-        switch (gestureName) {
-            case SWIPE_UP:
-            case SWIPE_DOWN:
-                break;
-            case SWIPE_LEFT:
-                constants.isRTL ? onSwipeRight() : onSwipeLeft();
-                break;
-            case SWIPE_RIGHT:
-                constants.isRTL ? onSwipeLeft() : onSwipeRight();
-                break;
-        }
-    }, [onSwipeLeft, onSwipeRight]);
-    const renderWeekNumber = (weekNumber) => {
-        return (<View style={style.current.dayContainer} key={`week-container-${weekNumber}`}>
-        <BasicDay key={`week-${weekNumber}`} marking={weekNumberMarking.current} 
-        // state='disabled'
-        theme={theme} testID={`${testID}.weekNumber_${weekNumber}`}>
+      }
+    },
+    [minDate, maxDate, allowSelectionOutOfRange, disableMonthChange, updateMonth],
+  );
+  const _onDayPress = useCallback(
+    (date) => {
+      if (date) handleDayInteraction(date, onDayPress);
+    },
+    [handleDayInteraction, onDayPress],
+  );
+  const onLongPressDay = useCallback(
+    (date) => {
+      if (date) handleDayInteraction(date, onDayLongPress);
+    },
+    [handleDayInteraction, onDayLongPress],
+  );
+  const onSwipeLeft = useCallback(() => {
+    // @ts-expect-error
+    header.current?.onPressRight();
+  }, [header]);
+  const onSwipeRight = useCallback(() => {
+    // @ts-expect-error
+    header.current?.onPressLeft();
+  }, [header]);
+  const onSwipe = useCallback(
+    (gestureName) => {
+      const { SWIPE_UP, SWIPE_DOWN, SWIPE_LEFT, SWIPE_RIGHT } = swipeDirections;
+      switch (gestureName) {
+        case SWIPE_UP:
+        case SWIPE_DOWN:
+          break;
+        case SWIPE_LEFT:
+          constants.isRTL ? onSwipeRight() : onSwipeLeft();
+          break;
+        case SWIPE_RIGHT:
+          constants.isRTL ? onSwipeLeft() : onSwipeRight();
+          break;
+      }
+    },
+    [onSwipeLeft, onSwipeRight],
+  );
+  const renderWeekNumber = (weekNumber) => {
+    return (
+      <View style={style.current.dayContainer} key={`week-container-${weekNumber}`}>
+        <BasicDay
+          key={`week-${weekNumber}`}
+          marking={weekNumberMarking.current}
+          // state='disabled'
+          theme={theme}
+          testID={`${testID}.weekNumber_${weekNumber}`}
+        >
           {weekNumber}
         </BasicDay>
-      </View>);
-    };
-    const renderDay = (day, id) => {
-        const dayProps = extractDayProps(props);
-        if (!sameMonth(day, currentMonth) && hideExtraDays) {
-            return <View key={id} style={style.current.emptyDayContainer}/>;
-        }
-        const dateString = toMarkingFormat(day);
-        const isControlled = isEmpty(props.context);
-        return (<View style={style.current.dayContainer} key={id}>
-        <Day {...dayProps} testID={`${testID}.day_${dateString}`} date={dateString} state={getState(day, currentMonth, props, isControlled)} marking={markedDates?.[dateString]} onPress={_onDayPress} onLongPress={onLongPressDay}/>
-      </View>);
-    };
-    const renderWeek = (days, id) => {
-        const week = [];
-        days.forEach((day, id2) => {
-            week.push(renderDay(day, id2));
-        }, this);
-        if (props.showWeekNumbers) {
-            week.unshift(renderWeekNumber(days[days.length - 1].getWeek()));
-        }
-        return (<View style={style.current.week} key={id}>
+      </View>
+    );
+  };
+  const renderDay = (day, id) => {
+    const dayProps = extractDayProps(props);
+    if (!sameMonth(day, currentMonth) && hideExtraDays) {
+      return <View key={id} style={style.current.emptyDayContainer} />;
+    }
+    const dateString = toMarkingFormat(day);
+    const isControlled = isEmpty(props.context);
+    return (
+      <View style={style.current.dayContainer} key={id}>
+        <Day
+          {...dayProps}
+          testID={`${testID}.day_${dateString}`}
+          date={dateString}
+          state={getState(day, currentMonth, props, isControlled)}
+          marking={markedDates?.[dateString]}
+          onPress={_onDayPress}
+          onLongPress={onLongPressDay}
+        />
+      </View>
+    );
+  };
+  const renderWeek = (days, id) => {
+    const week = [];
+    days.forEach((day, id2) => {
+      week.push(renderDay(day, id2));
+    }, this);
+    if (props.showWeekNumbers) {
+      week.unshift(renderWeekNumber(days[days.length - 1].getWeek()));
+    }
+    return (
+      <View style={style.current.week} key={id}>
         {week}
-      </View>);
-    };
-    const renderMonth = () => {
-        const shouldShowSixWeeks = showSixWeeks && !hideExtraDays;
-        const days = page(currentMonth, firstDay, shouldShowSixWeeks);
-        const weeks = [];
-        while (days.length) {
-            weeks.push(renderWeek(days.splice(0, 7), weeks.length));
-        }
-        return <View style={style.current.monthView}>{weeks}</View>;
-    };
-    const shouldDisplayIndicator = useMemo(() => {
-        if (currentMonth) {
-            const lastMonthOfDay = toMarkingFormat(currentMonth.clone().addMonths(1, true).setDate(1).addDays(-1));
-            if (displayLoadingIndicator && !markedDates?.[lastMonthOfDay]) {
-                return true;
-            }
-        }
-        return false;
-    }, [currentMonth, displayLoadingIndicator, markedDates]);
-    const renderHeader = () => {
-        const headerProps = extractHeaderProps(props);
-        const ref = customHeader ? undefined : header;
-        const CustomHeader = customHeader;
-        const HeaderComponent = customHeader ? CustomHeader : CalendarHeader;
-        return (<HeaderComponent {...headerProps} testID={`${testID}.header`} style={headerStyle} ref={ref} month={currentMonth} addMonth={addMonth} displayLoadingIndicator={shouldDisplayIndicator}/>);
-    };
-    const GestureComponent = enableSwipeMonths ? GestureRecognizer : View;
-    const swipeProps = {
-        onSwipe: (direction) => onSwipe(direction)
-    };
-    const gestureProps = enableSwipeMonths ? swipeProps : undefined;
-    return (<GestureComponent {...gestureProps}>
-      <View style={[style.current.container, propsStyle]} testID={testID} accessibilityElementsHidden={accessibilityElementsHidden} // iOS
-     importantForAccessibility={importantForAccessibility} // Android
-    >
+      </View>
+    );
+  };
+  const renderMonth = () => {
+    const shouldShowSixWeeks = showSixWeeks && !hideExtraDays;
+    const days = page(currentMonth, firstDay, shouldShowSixWeeks);
+    const weeks = [];
+    while (days.length) {
+      weeks.push(renderWeek(days.splice(0, 7), weeks.length));
+    }
+    return <View style={style.current.monthView}>{weeks}</View>;
+  };
+  const shouldDisplayIndicator = useMemo(() => {
+    if (currentMonth) {
+      const lastMonthOfDay = toMarkingFormat(currentMonth.clone().addMonths(1, true).setDate(1).addDays(-1));
+      if (displayLoadingIndicator && !markedDates?.[lastMonthOfDay]) {
+        return true;
+      }
+    }
+    return false;
+  }, [currentMonth, displayLoadingIndicator, markedDates]);
+  const renderHeader = () => {
+    const headerProps = extractHeaderProps(props);
+    const ref = customHeader ? undefined : header;
+    const CustomHeader = customHeader;
+    const HeaderComponent = customHeader ? CustomHeader : CalendarHeader;
+    return (
+      <HeaderComponent
+        {...headerProps}
+        testID={`${testID}.header`}
+        style={headerStyle}
+        ref={ref}
+        month={currentMonth}
+        addMonth={addMonth}
+        displayLoadingIndicator={shouldDisplayIndicator}
+      />
+    );
+  };
+  const GestureComponent = enableSwipeMonths ? GestureRecognizer : View;
+  const swipeProps = {
+    onSwipe: (direction) => onSwipe(direction),
+  };
+  const gestureProps = enableSwipeMonths ? swipeProps : undefined;
+  return (
+    <GestureComponent {...gestureProps}>
+      <View
+        style={[style.current.container, propsStyle]}
+        testID={testID}
+        accessibilityElementsHidden={accessibilityElementsHidden} // iOS
+        importantForAccessibility={importantForAccessibility} // Android
+      >
         {renderHeader()}
         {renderMonth()}
       </View>
-    </GestureComponent>);
+    </GestureComponent>
+  );
 };
 export default Calendar;
 Calendar.displayName = 'Calendar';
 Calendar.propTypes = {
-    ...CalendarHeader.propTypes,
-    ...Day.propTypes,
-    theme: PropTypes.object,
-    firstDay: PropTypes.number,
-    displayLoadingIndicator: PropTypes.bool,
-    showWeekNumbers: PropTypes.bool,
-    style: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.number]),
-    current: PropTypes.string,
-    initialDate: PropTypes.string,
-    minDate: PropTypes.string,
-    maxDate: PropTypes.string,
-    markedDates: PropTypes.object,
-    hideExtraDays: PropTypes.bool,
-    showSixWeeks: PropTypes.bool,
-    onDayPress: PropTypes.func,
-    onDayLongPress: PropTypes.func,
-    onMonthChange: PropTypes.func,
-    onVisibleMonthsChange: PropTypes.func,
-    disableMonthChange: PropTypes.bool,
-    enableSwipeMonths: PropTypes.bool,
-    disabledByDefault: PropTypes.bool,
-    headerStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),
-    customHeader: PropTypes.any,
-    allowSelectionOutOfRange: PropTypes.bool
+  ...CalendarHeader.propTypes,
+  ...Day.propTypes,
+  theme: PropTypes.object,
+  firstDay: PropTypes.number,
+  displayLoadingIndicator: PropTypes.bool,
+  showWeekNumbers: PropTypes.bool,
+  style: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.number]),
+  current: PropTypes.string,
+  initialDate: PropTypes.string,
+  minDate: PropTypes.string,
+  maxDate: PropTypes.string,
+  markedDates: PropTypes.object,
+  hideExtraDays: PropTypes.bool,
+  showSixWeeks: PropTypes.bool,
+  onDayPress: PropTypes.func,
+  onDayLongPress: PropTypes.func,
+  onMonthChange: PropTypes.func,
+  onVisibleMonthsChange: PropTypes.func,
+  disableMonthChange: PropTypes.bool,
+  enableSwipeMonths: PropTypes.bool,
+  disabledByDefault: PropTypes.bool,
+  headerStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),
+  customHeader: PropTypes.any,
+  allowSelectionOutOfRange: PropTypes.bool,
 };
diff --git a/node_modules/react-native-calendars/src/calendar/style.js b/node_modules/react-native-calendars/src/calendar/style.js
index 735afb5..e5d7a16 100644
--- a/node_modules/react-native-calendars/src/calendar/style.js
+++ b/node_modules/react-native-calendars/src/calendar/style.js
@@ -1,28 +1,36 @@
 import { StyleSheet } from 'react-native';
+
 import * as defaultStyle from '../style';
+
 export default function getStyle(theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        container: {
-            paddingLeft: 5,
-            paddingRight: 5,
-            backgroundColor: appStyle.calendarBackground
-        },
-        dayContainer: {
-            flex: 1,
-            alignItems: 'center'
-        },
-        emptyDayContainer: {
-            flex: 1
-        },
-        monthView: {
-            backgroundColor: appStyle.calendarBackground
-        },
-        week: {
-            marginVertical: appStyle.weekVerticalMargin,
-            flexDirection: 'row',
-            justifyContent: 'space-around'
-        },
-        ...(theme['stylesheet.calendar.main'] || {})
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    container: {
+      paddingLeft: 5,
+      paddingRight: 5,
+      backgroundColor: appStyle.calendarBackground,
+    },
+    dayContainer: {
+      flex: 1,
+      alignItems: 'center',
+      paddingTop: 6,
+      paddingBottom: 12,
+      borderTopWidth: 0.3,
+      borderTopColor: '#AEAEB2',
+    },
+    emptyDayContainer: {
+      flex: 1,
+    },
+    monthView: {
+      backgroundColor: appStyle.calendarBackground,
+    },
+    week: {
+      marginVertical: appStyle.weekVerticalMargin,
+      paddingLeft: 5,
+      paddingRight: 5,
+      flexDirection: 'row',
+      justifyContent: 'space-around',
+    },
+    ...(theme['stylesheet.calendar.main'] || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/commons/WeekDaysNames.js b/node_modules/react-native-calendars/src/commons/WeekDaysNames.js
index f57b436..ebd1f4a 100644
--- a/node_modules/react-native-calendars/src/commons/WeekDaysNames.js
+++ b/node_modules/react-native-calendars/src/commons/WeekDaysNames.js
@@ -1,10 +1,14 @@
 import React from 'react';
 import { Text } from 'react-native';
+
 import { weekDayNames } from '../dateutils';
+
 const WeekDaysNames = React.memo(({ firstDay, style }) => {
-    const dayNames = weekDayNames(firstDay);
-    return dayNames.map((day, index) => (<Text allowFontScaling={false} key={index} style={style} numberOfLines={1} accessibilityLabel={''}>
+  const dayNames = weekDayNames(firstDay);
+  return dayNames.map((day, index) => (
+    <Text allowFontScaling={false} key={index} style={style} numberOfLines={1} accessibilityLabel={''}>
       {day}
-    </Text>));
+    </Text>
+  ));
 });
 export default WeekDaysNames;
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/index.js b/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/index.js
index c030f84..2afcb58 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/index.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/index.js
@@ -1,16 +1,19 @@
-import XDate from 'xdate';
 import React, { useCallback, useContext, useMemo, useRef, useState } from 'react';
 import { FlatList, View } from 'react-native';
-import { sameWeek, onSameDateRange, getWeekDates } from '../../dateutils';
-import { toMarkingFormat } from '../../interface';
-import styleConstructor from '../style';
+
+import XDate from 'xdate';
+
 import WeekDaysNames from '../../commons/WeekDaysNames';
-import Week from '../week';
-import { UpdateSources } from '../commons';
 import constants from '../../commons/constants';
 import { extractCalendarProps } from '../../componentUpdater';
-import CalendarContext from '../Context';
+import { getWeekDates, onSameDateRange, sameWeek } from '../../dateutils';
 import { useDidUpdate } from '../../hooks';
+import { toMarkingFormat } from '../../interface';
+import CalendarContext from '../Context';
+import { UpdateSources } from '../commons';
+import styleConstructor from '../style';
+import Week from '../week';
+
 export const NUMBER_OF_PAGES = 6;
 const NUM_OF_ITEMS = NUMBER_OF_PAGES * 2 + 1; // NUMBER_OF_PAGES before + NUMBER_OF_PAGES after + current
 /**
@@ -19,184 +22,225 @@ const NUM_OF_ITEMS = NUMBER_OF_PAGES * 2 + 1; // NUMBER_OF_PAGES before + NUMBER
  * @example: https://github.com/wix/react-native-calendars/blob/master/example/src/screens/expandableCalendar.js
  */
 const WeekCalendar = (props) => {
-    const { calendarWidth, hideDayNames, current, theme, testID, markedDates, } = props;
-    const context = useContext(CalendarContext);
-    const { allowShadow = true, ...calendarListProps } = props;
-    const { style: propsStyle, onDayPress, firstDay = 0, ...others } = extractCalendarProps(calendarListProps);
-    const { date, numberOfDays, updateSource, setDate, timelineLeftInset } = context;
-    const visibleWeek = useRef(date);
-    const style = useRef(styleConstructor(theme));
-    const items = useRef(getDatesArray(current ?? date, firstDay, numberOfDays));
-    const [listData, setListData] = useState(items.current);
-    const changedItems = useRef(constants.isRTL);
-    const list = useRef(null);
-    const currentIndex = useRef(NUMBER_OF_PAGES);
-    useDidUpdate(() => {
-        items.current = getDatesArray(date, firstDay, numberOfDays);
-        setListData(items.current);
-        visibleWeek.current = date;
-        list?.current?.scrollToIndex({ index: NUMBER_OF_PAGES, animated: false });
-    }, [numberOfDays]);
-    useDidUpdate(() => {
-        if (updateSource !== UpdateSources.WEEK_SCROLL) {
-            const pageIndex = items.current.findIndex(item => isCustomNumberOfDays(numberOfDays) ?
-                onSameDateRange({
-                    firstDay: item,
-                    secondDay: date,
-                    numberOfDays: numberOfDays,
-                    firstDateInRange: item
-                }) :
-                sameWeek(item, date, firstDay));
-            if (pageIndex !== currentIndex.current) {
-                const adjustedIndexFrScroll = constants.isAndroidRTL ? NUM_OF_ITEMS - 1 - pageIndex : pageIndex;
-                if (pageIndex >= 0) {
-                    visibleWeek.current = items.current[adjustedIndexFrScroll];
-                    currentIndex.current = adjustedIndexFrScroll;
-                }
-                else {
-                    visibleWeek.current = date;
-                    currentIndex.current = NUMBER_OF_PAGES;
-                }
-                pageIndex <= 0 ? onEndReached() : list?.current?.scrollToIndex({ index: adjustedIndexFrScroll, animated: false });
-            }
+  const { calendarWidth, hideDayNames, current, theme, testID, markedDates } = props;
+  const context = useContext(CalendarContext);
+  const { allowShadow = true, ...calendarListProps } = props;
+  const { style: propsStyle, onDayPress, firstDay = 0, ...others } = extractCalendarProps(calendarListProps);
+  const { date, numberOfDays, updateSource, setDate, timelineLeftInset } = context;
+  const visibleWeek = useRef(date);
+  const style = useRef(styleConstructor(theme));
+  const items = useRef(getDatesArray(current ?? date, firstDay, numberOfDays));
+  const [listData, setListData] = useState(items.current);
+  const changedItems = useRef(constants.isRTL);
+  const list = useRef(null);
+  const currentIndex = useRef(NUMBER_OF_PAGES);
+  useDidUpdate(() => {
+    items.current = getDatesArray(date, firstDay, numberOfDays);
+    setListData(items.current);
+    visibleWeek.current = date;
+    list?.current?.scrollToIndex({ index: NUMBER_OF_PAGES, animated: false });
+  }, [numberOfDays]);
+  useDidUpdate(() => {
+    if (updateSource !== UpdateSources.WEEK_SCROLL) {
+      const pageIndex = items.current.findIndex((item) =>
+        isCustomNumberOfDays(numberOfDays)
+          ? onSameDateRange({
+              firstDay: item,
+              secondDay: date,
+              numberOfDays: numberOfDays,
+              firstDateInRange: item,
+            })
+          : sameWeek(item, date, firstDay),
+      );
+      if (pageIndex !== currentIndex.current) {
+        const adjustedIndexFrScroll = constants.isAndroidRTL ? NUM_OF_ITEMS - 1 - pageIndex : pageIndex;
+        if (pageIndex >= 0) {
+          visibleWeek.current = items.current[adjustedIndexFrScroll];
+          currentIndex.current = adjustedIndexFrScroll;
+        } else {
+          visibleWeek.current = date;
+          currentIndex.current = NUMBER_OF_PAGES;
         }
-    }, [date, updateSource]);
-    const containerWidth = useMemo(() => {
-        return calendarWidth ?? constants.screenWidth;
-    }, [calendarWidth]);
-    const _onDayPress = useCallback((value) => {
-        if (onDayPress) {
-            onDayPress(value);
-        }
-        else {
-            setDate?.(value.dateString, UpdateSources.DAY_PRESS);
-        }
-    }, [onDayPress]);
-    const getCurrentWeekMarkings = useCallback((date, markings) => {
-        if (!markings) {
-            return;
-        }
-        const dates = getWeekDates(date, firstDay);
-        return dates?.reduce((acc, date) => {
-            const dateString = toMarkingFormat(date);
-            return {
-                ...acc,
-                ...(markings[dateString] && { [dateString]: markings[dateString] }),
-            };
-        }, {});
-    }, []);
-    const weekStyle = useMemo(() => {
-        return [{ width: containerWidth }, propsStyle];
-    }, [containerWidth, propsStyle]);
-    const renderItem = useCallback(({ item }) => {
-        const currentContext = sameWeek(date, item, firstDay) ? context : undefined;
-        const markings = getCurrentWeekMarkings(item, markedDates);
-        return (<Week {...others} markedDates={markings} current={item} firstDay={firstDay} style={weekStyle} context={currentContext} onDayPress={_onDayPress} numberOfDays={numberOfDays} timelineLeftInset={timelineLeftInset}/>);
-    }, [firstDay, _onDayPress, context, date, markedDates]);
-    const keyExtractor = useCallback((item) => item, []);
-    const renderWeekDaysNames = useMemo(() => {
-        return (<WeekDaysNames firstDay={firstDay} style={style.current.dayHeader}/>);
-    }, [firstDay]);
-    const weekCalendarStyle = useMemo(() => {
-        return [
-            allowShadow && style.current.containerShadow,
-            !hideDayNames && style.current.containerWrapper
-        ];
-    }, [allowShadow, hideDayNames]);
-    const containerStyle = useMemo(() => {
-        return [style.current.week, style.current.weekCalendar];
-    }, []);
-    const getItemLayout = useCallback((_, index) => {
-        return {
-            length: containerWidth,
-            offset: containerWidth * index,
-            index
-        };
-    }, [containerWidth]);
-    const onEndReached = useCallback(() => {
-        changedItems.current = true;
-        items.current = (getDatesArray(visibleWeek.current, firstDay, numberOfDays));
-        setListData(items.current);
-        currentIndex.current = NUMBER_OF_PAGES;
-        list?.current?.scrollToIndex({ index: NUMBER_OF_PAGES, animated: false });
-    }, [firstDay, numberOfDays]);
-    const onViewableItemsChanged = useCallback(({ viewableItems }) => {
-        if (changedItems.current || viewableItems.length === 0) {
-            changedItems.current = false;
-            return;
-        }
-        const currItems = items.current;
-        const newDate = viewableItems[0]?.item;
-        if (newDate !== visibleWeek.current) {
-            if (constants.isAndroidRTL) {
-                //in android RTL the item we see is the one in the opposite direction
-                const newDateOffset = -1 * (NUMBER_OF_PAGES - currItems.indexOf(newDate));
-                const adjustedNewDate = currItems[NUMBER_OF_PAGES - newDateOffset];
-                visibleWeek.current = adjustedNewDate;
-                currentIndex.current = currItems.indexOf(adjustedNewDate);
-                setDate(adjustedNewDate, UpdateSources.WEEK_SCROLL);
-                if (visibleWeek.current === currItems[currItems.length - 1]) {
-                    onEndReached();
-                }
-            }
-            else {
-                currentIndex.current = currItems.indexOf(newDate);
-                visibleWeek.current = newDate;
-                setDate(newDate, UpdateSources.WEEK_SCROLL);
-                if (visibleWeek.current === currItems[0]) {
-                    onEndReached();
-                }
-            }
+        pageIndex <= 0
+          ? onEndReached()
+          : list?.current?.scrollToIndex({ index: adjustedIndexFrScroll, animated: false });
+      }
+    }
+  }, [date, updateSource]);
+  const containerWidth = useMemo(() => {
+    return calendarWidth ?? constants.screenWidth;
+  }, [calendarWidth]);
+  const _onDayPress = useCallback(
+    (value) => {
+      if (onDayPress) {
+        onDayPress(value);
+      } else {
+        setDate?.(value.dateString, UpdateSources.DAY_PRESS);
+      }
+    },
+    [onDayPress],
+  );
+  const getCurrentWeekMarkings = useCallback((date, markings) => {
+    if (!markings) {
+      return;
+    }
+    const dates = getWeekDates(date, firstDay);
+    return dates?.reduce((acc, date) => {
+      const dateString = toMarkingFormat(date);
+      return {
+        ...acc,
+        ...(markings[dateString] && { [dateString]: markings[dateString] }),
+      };
+    }, {});
+  }, []);
+  const weekStyle = useMemo(() => {
+    return [{ width: containerWidth }, propsStyle];
+  }, [containerWidth, propsStyle]);
+  const renderItem = useCallback(
+    ({ item }) => {
+      const currentContext = sameWeek(date, item, firstDay) ? context : undefined;
+      const markings = getCurrentWeekMarkings(item, markedDates);
+      return (
+        <Week
+          {...others}
+          markedDates={markings}
+          current={item}
+          firstDay={firstDay}
+          style={weekStyle}
+          context={currentContext}
+          onDayPress={_onDayPress}
+          numberOfDays={numberOfDays}
+          timelineLeftInset={timelineLeftInset}
+        />
+      );
+    },
+    [firstDay, _onDayPress, context, date, markedDates],
+  );
+  const keyExtractor = useCallback((item) => item, []);
+  const renderWeekDaysNames = useMemo(() => {
+    return <WeekDaysNames firstDay={firstDay} style={style.current.dayHeader} />;
+  }, [firstDay]);
+  const weekCalendarStyle = useMemo(() => {
+    return [allowShadow && style.current.containerShadow, !hideDayNames && style.current.containerWrapper];
+  }, [allowShadow, hideDayNames]);
+
+  const containerStyle = useMemo(() => {
+    return [style.current.week, style.current.weekCalendar];
+  }, []);
+  const getItemLayout = useCallback(
+    (_, index) => {
+      return {
+        length: containerWidth,
+        offset: containerWidth * index,
+        index,
+      };
+    },
+    [containerWidth],
+  );
+  const onEndReached = useCallback(() => {
+    changedItems.current = true;
+    items.current = getDatesArray(visibleWeek.current, firstDay, numberOfDays);
+    setListData(items.current);
+    currentIndex.current = NUMBER_OF_PAGES;
+    list?.current?.scrollToIndex({ index: NUMBER_OF_PAGES, animated: false });
+  }, [firstDay, numberOfDays]);
+  const onViewableItemsChanged = useCallback(
+    ({ viewableItems }) => {
+      if (changedItems.current || viewableItems.length === 0) {
+        changedItems.current = false;
+        return;
+      }
+      const currItems = items.current;
+      const newDate = viewableItems[0]?.item;
+      if (newDate !== visibleWeek.current) {
+        if (constants.isAndroidRTL) {
+          //in android RTL the item we see is the one in the opposite direction
+          const newDateOffset = -1 * (NUMBER_OF_PAGES - currItems.indexOf(newDate));
+          const adjustedNewDate = currItems[NUMBER_OF_PAGES - newDateOffset];
+          visibleWeek.current = adjustedNewDate;
+          currentIndex.current = currItems.indexOf(adjustedNewDate);
+          setDate(adjustedNewDate, UpdateSources.WEEK_SCROLL);
+          if (visibleWeek.current === currItems[currItems.length - 1]) {
+            onEndReached();
+          }
+        } else {
+          currentIndex.current = currItems.indexOf(newDate);
+          visibleWeek.current = newDate;
+          setDate(newDate, UpdateSources.WEEK_SCROLL);
+          if (visibleWeek.current === currItems[0]) {
+            onEndReached();
+          }
         }
-    }, [onEndReached]);
-    const viewabilityConfigCallbackPairs = useRef([{
-            viewabilityConfig: {
-                itemVisiblePercentThreshold: 20,
-            },
-            onViewableItemsChanged,
-        }]);
-    return (<View testID={testID} style={weekCalendarStyle}>
-      {!hideDayNames && (<View style={containerStyle}>
-          {renderWeekDaysNames}
-        </View>)}
+      }
+    },
+    [onEndReached],
+  );
+  const viewabilityConfigCallbackPairs = useRef([
+    {
+      viewabilityConfig: {
+        itemVisiblePercentThreshold: 20,
+      },
+      onViewableItemsChanged,
+    },
+  ]);
+  return (
+    <View testID={testID} style={weekCalendarStyle}>
+      {!hideDayNames && <View style={containerStyle}>{renderWeekDaysNames}</View>}
       <View style={style.current.container}>
-          <FlatList testID={`${testID}.list`} ref={list} style={style.current.container} data={listData} horizontal showsHorizontalScrollIndicator={false} pagingEnabled scrollEnabled renderItem={renderItem} keyExtractor={keyExtractor} initialScrollIndex={NUMBER_OF_PAGES} getItemLayout={getItemLayout} viewabilityConfigCallbackPairs={viewabilityConfigCallbackPairs.current} onEndReached={onEndReached} onEndReachedThreshold={1 / NUM_OF_ITEMS}/>
+        <FlatList
+          testID={`${testID}.list`}
+          ref={list}
+          style={style.current.container}
+          data={listData}
+          horizontal
+          showsHorizontalScrollIndicator={false}
+          pagingEnabled
+          scrollEnabled
+          renderItem={renderItem}
+          keyExtractor={keyExtractor}
+          initialScrollIndex={NUMBER_OF_PAGES}
+          getItemLayout={getItemLayout}
+          viewabilityConfigCallbackPairs={viewabilityConfigCallbackPairs.current}
+          onEndReached={onEndReached}
+          onEndReachedThreshold={1 / NUM_OF_ITEMS}
+        />
       </View>
-    </View>);
+    </View>
+  );
 };
 function getDateForDayRange(date, weekIndex, numberOfDays) {
-    const d = new XDate(date);
-    if (weekIndex !== 0) {
-        d.addDays(numberOfDays * weekIndex);
-    }
-    return toMarkingFormat(d);
+  const d = new XDate(date);
+  if (weekIndex !== 0) {
+    d.addDays(numberOfDays * weekIndex);
+  }
+  return toMarkingFormat(d);
 }
 function getDate(date, firstDay, weekIndex, numberOfDays) {
-    const d = new XDate(date);
-    // get the first day of the week as date (for the on scroll mark)
-    let dayOfTheWeek = d.getDay();
-    if (dayOfTheWeek < firstDay && firstDay > 0) {
-        dayOfTheWeek = 7 + dayOfTheWeek;
-    }
-    if (weekIndex !== 0) {
-        d.addDays(firstDay - dayOfTheWeek);
-    }
-    const newDate = numberOfDays && numberOfDays > 1 ? d.addDays(weekIndex * numberOfDays) : d.addWeeks(weekIndex);
-    const today = new XDate();
-    const offsetFromNow = newDate.diffDays(today);
-    const isSameWeek = offsetFromNow > 0 && offsetFromNow < (numberOfDays ?? 7);
-    return toMarkingFormat(isSameWeek ? today : newDate);
+  const d = new XDate(date);
+  // get the first day of the week as date (for the on scroll mark)
+  let dayOfTheWeek = d.getDay();
+  if (dayOfTheWeek < firstDay && firstDay > 0) {
+    dayOfTheWeek = 7 + dayOfTheWeek;
+  }
+  if (weekIndex !== 0) {
+    d.addDays(firstDay - dayOfTheWeek);
+  }
+  const newDate = numberOfDays && numberOfDays > 1 ? d.addDays(weekIndex * numberOfDays) : d.addWeeks(weekIndex);
+  const today = new XDate();
+  const offsetFromNow = newDate.diffDays(today);
+  const isSameWeek = offsetFromNow > 0 && offsetFromNow < (numberOfDays ?? 7);
+  return toMarkingFormat(isSameWeek ? today : newDate);
 }
 function getDatesArray(date, firstDay, numberOfDays) {
-    return [...Array(NUM_OF_ITEMS).keys()].map((index) => {
-        if (isCustomNumberOfDays(numberOfDays)) {
-            return getDateForDayRange(date, index - NUMBER_OF_PAGES, numberOfDays);
-        }
-        return getDate(date, firstDay, index - NUMBER_OF_PAGES);
-    });
+  return [...Array(NUM_OF_ITEMS).keys()].map((index) => {
+    if (isCustomNumberOfDays(numberOfDays)) {
+      return getDateForDayRange(date, index - NUMBER_OF_PAGES, numberOfDays);
+    }
+    return getDate(date, firstDay, index - NUMBER_OF_PAGES);
+  });
 }
 function isCustomNumberOfDays(numberOfDays) {
-    return numberOfDays && numberOfDays > 1;
+  return numberOfDays && numberOfDays > 1;
 }
 WeekCalendar.displayName = 'WeekCalendar';
 export default WeekCalendar;
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/new.js b/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/new.js
index b7e3a65..1164aa3 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/new.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/WeekCalendar/new.js
@@ -1,92 +1,150 @@
 import React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
 import { View } from 'react-native';
+
 import XDate from 'xdate';
-import InfiniteList from '../../infinite-list';
-import Week from '../week';
+
 import WeekDaysNames from '../../commons/WeekDaysNames';
+import constants from '../../commons/constants';
+import { extractCalendarProps } from '../../componentUpdater';
+import { sameWeek } from '../../dateutils';
 import CalendarContext from '../../expandableCalendar/Context';
-import styleConstructor from '../style';
+import InfiniteList from '../../infinite-list';
 import { toMarkingFormat } from '../../interface';
-import { extractCalendarProps } from '../../componentUpdater';
-import constants from '../../commons/constants';
 import { UpdateSources } from '../commons';
-import { sameWeek } from '../../dateutils';
+import styleConstructor from '../style';
+import Week from '../week';
+
 const NUMBER_OF_PAGES = 50;
 const DEFAULT_PAGE_HEIGHT = 48;
 const WeekCalendar = (props) => {
-    const { current, firstDay = 0, markedDates, allowShadow = true, hideDayNames, theme, calendarWidth, calendarHeight = DEFAULT_PAGE_HEIGHT, testID } = props;
-    const context = useContext(CalendarContext);
-    const { date, updateSource } = context;
-    const style = useRef(styleConstructor(theme));
-    const list = useRef();
-    const [items, setItems] = useState(getDatesArray(current || date, firstDay, NUMBER_OF_PAGES));
-    const extraData = {
-        current,
-        date: context.date,
-        firstDay
-    };
-    const containerWidth = calendarWidth || constants.screenWidth;
-    const weekStyle = useMemo(() => {
-        return [{ width: containerWidth }, props.style];
-    }, [containerWidth, props.style]);
-    useEffect(() => {
-        if (updateSource !== UpdateSources.WEEK_SCROLL) {
-            const pageIndex = items.findIndex(item => sameWeek(item, date, firstDay));
-            // @ts-expect-error
-            list.current?.scrollToOffset?.(pageIndex * containerWidth, 0, false);
-        }
-    }, [date]);
-    const onDayPress = useCallback((dateData) => {
-        context.setDate?.(dateData.dateString, UpdateSources.DAY_PRESS);
-        props.onDayPress?.(dateData);
-    }, [props.onDayPress]);
-    const onPageChange = useCallback((pageIndex, _prevPage, { scrolledByUser }) => {
-        if (scrolledByUser) {
-            context?.setDate(items[pageIndex], UpdateSources.WEEK_SCROLL);
-        }
-    }, [items]);
-    const reloadPages = useCallback(pageIndex => {
-        const date = items[pageIndex];
-        setItems(getDatesArray(date, firstDay, NUMBER_OF_PAGES));
-    }, [items]);
-    const renderItem = useCallback((_type, item) => {
-        const { allowShadow, ...calendarListProps } = props;
-        const { /* style,  */ ...others } = extractCalendarProps(calendarListProps);
-        const isSameWeek = sameWeek(item, date, firstDay);
-        return (<Week {...others} key={item} current={isSameWeek ? date : item} firstDay={firstDay} style={weekStyle} markedDates={markedDates} onDayPress={onDayPress} context={context}/>);
-    }, [date, markedDates]);
-    return (<View testID={testID} style={[allowShadow && style.current.containerShadow, !hideDayNames && style.current.containerWrapper]}>
-      {!hideDayNames && (<View style={[style.current.week, style.current.weekCalendar]}>
-          <WeekDaysNames firstDay={firstDay} style={style.current.dayHeader}/>
-        </View>)}
+  const {
+    current,
+    firstDay = 0,
+    markedDates,
+    allowShadow = true,
+    hideDayNames,
+    theme,
+    calendarWidth,
+    calendarHeight = DEFAULT_PAGE_HEIGHT,
+    testID,
+  } = props;
+  const context = useContext(CalendarContext);
+  const { date, updateSource } = context;
+  const style = useRef(styleConstructor(theme));
+  const list = useRef();
+  const [items, setItems] = useState(getDatesArray(current || date, firstDay, NUMBER_OF_PAGES));
+  const extraData = {
+    current,
+    date: context.date,
+    firstDay,
+  };
+  const containerWidth = calendarWidth || constants.screenWidth;
+  const weekStyle = useMemo(() => {
+    return [{ width: containerWidth }, props.style];
+  }, [containerWidth, props.style]);
+  useEffect(() => {
+    if (updateSource !== UpdateSources.WEEK_SCROLL) {
+      const pageIndex = items.findIndex((item) => sameWeek(item, date, firstDay));
+      // @ts-expect-error
+      list.current?.scrollToOffset?.(pageIndex * containerWidth, 0, false);
+    }
+  }, [date]);
+  const onDayPress = useCallback(
+    (dateData) => {
+      context.setDate?.(dateData.dateString, UpdateSources.DAY_PRESS);
+      props.onDayPress?.(dateData);
+    },
+    [props.onDayPress],
+  );
+  const onPageChange = useCallback(
+    (pageIndex, _prevPage, { scrolledByUser }) => {
+      if (scrolledByUser) {
+        context?.setDate(items[pageIndex], UpdateSources.WEEK_SCROLL);
+      }
+    },
+    [items],
+  );
+  const reloadPages = useCallback(
+    (pageIndex) => {
+      const date = items[pageIndex];
+      setItems(getDatesArray(date, firstDay, NUMBER_OF_PAGES));
+    },
+    [items],
+  );
+  const renderItem = useCallback(
+    (_type, item) => {
+      const { allowShadow, ...calendarListProps } = props;
+      const { /* style,  */ ...others } = extractCalendarProps(calendarListProps);
+      const isSameWeek = sameWeek(item, date, firstDay);
+      return (
+        <Week
+          {...others}
+          key={item}
+          current={isSameWeek ? date : item}
+          firstDay={firstDay}
+          style={weekStyle}
+          markedDates={markedDates}
+          onDayPress={onDayPress}
+          context={context}
+        />
+      );
+    },
+    [date, markedDates],
+  );
+  return (
+    <View
+      testID={testID}
+      style={[allowShadow && style.current.containerShadow, !hideDayNames && style.current.containerWrapper]}
+    >
+      {!hideDayNames && (
+        <View style={[style.current.week, style.current.weekCalendar]}>
+          <WeekDaysNames firstDay={firstDay} style={style.current.dayHeader} />
+        </View>
+      )}
       <View>
-        <InfiniteList key="week-list" isHorizontal ref={list} data={items} renderItem={renderItem} reloadPages={reloadPages} onReachNearEdgeThreshold={Math.round(NUMBER_OF_PAGES * 0.4)} extendedState={extraData} style={style.current.container} initialPageIndex={NUMBER_OF_PAGES} pageHeight={calendarHeight} pageWidth={containerWidth} onPageChange={onPageChange} scrollViewProps={{
-            showsHorizontalScrollIndicator: false
-        }}/>
+        <InfiniteList
+          key="week-list"
+          isHorizontal
+          ref={list}
+          data={items}
+          renderItem={renderItem}
+          reloadPages={reloadPages}
+          onReachNearEdgeThreshold={Math.round(NUMBER_OF_PAGES * 0.4)}
+          extendedState={extraData}
+          style={style.current.container}
+          initialPageIndex={NUMBER_OF_PAGES}
+          pageHeight={calendarHeight}
+          pageWidth={containerWidth}
+          onPageChange={onPageChange}
+          scrollViewProps={{
+            showsHorizontalScrollIndicator: false,
+          }}
+        />
       </View>
-    </View>);
+    </View>
+  );
 };
 export default WeekCalendar;
 // function getDate({current, context, firstDay = 0}: WeekCalendarProps, weekIndex: number) {
 function getDate(date, firstDay, weekIndex) {
-    // const d = new XDate(current || context.date);
-    const d = new XDate(date);
-    // get the first day of the week as date (for the on scroll mark)
-    let dayOfTheWeek = d.getDay();
-    if (dayOfTheWeek < firstDay && firstDay > 0) {
-        dayOfTheWeek = 7 + dayOfTheWeek;
-    }
-    // leave the current date in the visible week as is
-    const dd = weekIndex === 0 ? d : d.addDays(firstDay - dayOfTheWeek);
-    const newDate = dd.addWeeks(weekIndex);
-    return toMarkingFormat(newDate);
+  // const d = new XDate(current || context.date);
+  const d = new XDate(date);
+  // get the first day of the week as date (for the on scroll mark)
+  let dayOfTheWeek = d.getDay();
+  if (dayOfTheWeek < firstDay && firstDay > 0) {
+    dayOfTheWeek = 7 + dayOfTheWeek;
+  }
+  // leave the current date in the visible week as is
+  const dd = weekIndex === 0 ? d : d.addDays(firstDay - dayOfTheWeek);
+  const newDate = dd.addWeeks(weekIndex);
+  return toMarkingFormat(newDate);
 }
 // function getDatesArray(args: WeekCalendarProps, numberOfPages = NUMBER_OF_PAGES) => {
 function getDatesArray(date, firstDay, numberOfPages = NUMBER_OF_PAGES) {
-    const array = [];
-    for (let index = -numberOfPages; index <= numberOfPages; index++) {
-        const d = getDate(date, firstDay, index);
-        array.push(d);
-    }
-    return array;
+  const array = [];
+  for (let index = -numberOfPages; index <= numberOfPages; index++) {
+    const d = getDate(date, firstDay, index);
+    array.push(d);
+  }
+  return array;
 }
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/agendaList.js b/node_modules/react-native-calendars/src/expandableCalendar/agendaList.js
index d485d8d..4f8eddf 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/agendaList.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/agendaList.js
@@ -1,25 +1,29 @@
-import PropTypes from 'prop-types';
+import React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';
+import { SectionList } from 'react-native';
+
+import debounce from 'lodash/debounce';
 import get from 'lodash/get';
-import map from 'lodash/map';
 import isFunction from 'lodash/isFunction';
 import isUndefined from 'lodash/isUndefined';
-import debounce from 'lodash/debounce';
+import map from 'lodash/map';
+import PropTypes from 'prop-types';
 import XDate from 'xdate';
-import React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';
-import { SectionList, } from 'react-native';
+
+import { AgendaSectionHeader } from './AgendaListsCommon';
+import Context from './Context';
+import { UpdateSources, todayString } from './commons';
+import InfiniteAgendaList from './infiniteAgendaList';
+import styleConstructor from './style';
+
+import constants from '../commons/constants';
+import { isGTE, isToday, sameDate } from '../dateutils';
 import { useDidUpdate } from '../hooks';
-import { getMoment } from '../momentResolver';
-import { isToday, isGTE, sameDate } from '../dateutils';
 import { parseDate } from '../interface';
+import { getMoment } from '../momentResolver';
 import { getDefaultLocale } from '../services';
-import { UpdateSources, todayString } from './commons';
-import constants from '../commons/constants';
-import styleConstructor from './style';
-import Context from './Context';
-import InfiniteAgendaList from './infiniteAgendaList';
-import { AgendaSectionHeader } from './AgendaListsCommon';
+
 const viewabilityConfig = {
-    itemVisiblePercentThreshold: 20 // 50 means if 50% of the item is visible
+  itemVisiblePercentThreshold: 20, // 50 means if 50% of the item is visible
 };
 /**
  * @description: AgendaList component
@@ -28,161 +32,217 @@ const viewabilityConfig = {
  * @example: https://github.com/wix/react-native-calendars/blob/master/example/src/screens/expandableCalendar.js
  */
 const AgendaList = (props) => {
-    if (props.infiniteListProps) {
-        return <InfiniteAgendaList {...props}/>;
+  if (props.infiniteListProps) {
+    return <InfiniteAgendaList {...props} />;
+  }
+  const {
+    theme,
+    sections,
+    scrollToNextEvent,
+    viewOffset = 0,
+    avoidDateUpdates,
+    onScroll,
+    onMomentumScrollBegin,
+    onMomentumScrollEnd,
+    onScrollToIndexFailed,
+    renderSectionHeader,
+    sectionStyle,
+    keyExtractor,
+    dayFormatter,
+    dayFormat = 'dddd, MMM d',
+    useMoment,
+    markToday = true,
+    onViewableItemsChanged,
+  } = props;
+  const { date, updateSource, setDate, setDisabled } = useContext(Context);
+  const style = useRef(styleConstructor(theme));
+  const list = useRef();
+  const _topSection = useRef(sections[0]?.title);
+  const didScroll = useRef(false);
+  const sectionScroll = useRef(false);
+  const sectionHeight = useRef(0);
+  useEffect(() => {
+    if (date !== _topSection.current) {
+      setTimeout(() => {
+        scrollToSection(date);
+      }, 500);
     }
-    const { theme, sections, scrollToNextEvent, viewOffset = 0, avoidDateUpdates, onScroll, onMomentumScrollBegin, onMomentumScrollEnd, onScrollToIndexFailed, renderSectionHeader, sectionStyle, keyExtractor, dayFormatter, dayFormat = 'dddd, MMM d', useMoment, markToday = true, onViewableItemsChanged, } = props;
-    const { date, updateSource, setDate, setDisabled } = useContext(Context);
-    const style = useRef(styleConstructor(theme));
-    const list = useRef();
-    const _topSection = useRef(sections[0]?.title);
-    const didScroll = useRef(false);
-    const sectionScroll = useRef(false);
-    const sectionHeight = useRef(0);
-    useEffect(() => {
-        if (date !== _topSection.current) {
-            setTimeout(() => {
-                scrollToSection(date);
-            }, 500);
-        }
-    }, []);
-    useDidUpdate(() => {
-        // NOTE: on first init data should set first section to the current date!!!
-        if (updateSource !== UpdateSources.LIST_DRAG && updateSource !== UpdateSources.CALENDAR_INIT) {
-            scrollToSection(date);
-        }
-    }, [date]);
-    const getSectionIndex = (date) => {
-        let i;
-        map(sections, (section, index) => {
-            // NOTE: sections titles should match current date format!!!
-            if (section.title === date) {
-                i = index;
-            }
-        });
-        return i;
-    };
-    const getNextSectionIndex = (date) => {
-        let i = 0;
-        for (let j = 1; j < sections.length; j++) {
-            const prev = parseDate(sections[j - 1]?.title);
-            const next = parseDate(sections[j]?.title);
-            const cur = new XDate(date);
-            if (isGTE(cur, prev) && isGTE(next, cur)) {
-                i = sameDate(prev, cur) ? j - 1 : j;
-                break;
-            }
-            else if (isGTE(cur, next)) {
-                i = j;
-            }
-        }
-        return i;
-    };
-    const getSectionTitle = useCallback((title) => {
-        if (!title)
-            return;
-        let sectionTitle = title;
-        if (dayFormatter) {
-            sectionTitle = dayFormatter(title);
-        }
-        else if (dayFormat) {
-            if (useMoment) {
-                const moment = getMoment();
-                sectionTitle = moment(title).format(dayFormat);
-            }
-            else {
-                sectionTitle = new XDate(title).toString(dayFormat);
-            }
-        }
-        if (markToday) {
-            const string = getDefaultLocale().today || todayString;
-            const today = isToday(title);
-            sectionTitle = today ? `${string}, ${sectionTitle}` : sectionTitle;
-        }
-        return sectionTitle;
-    }, []);
-    const scrollToSection = useCallback(debounce((d) => {
+  }, []);
+  useDidUpdate(() => {
+    // NOTE: on first init data should set first section to the current date!!!
+    if (updateSource !== UpdateSources.LIST_DRAG && updateSource !== UpdateSources.CALENDAR_INIT) {
+      scrollToSection(date);
+    }
+  }, [date]);
+  const getSectionIndex = (date) => {
+    let i;
+    map(sections, (section, index) => {
+      // NOTE: sections titles should match current date format!!!
+      if (section.title === date) {
+        i = index;
+      }
+    });
+    return i;
+  };
+  const getNextSectionIndex = (date) => {
+    let i = 0;
+    for (let j = 1; j < sections.length; j++) {
+      const prev = parseDate(sections[j - 1]?.title);
+      const next = parseDate(sections[j]?.title);
+      const cur = new XDate(date);
+      if (isGTE(cur, prev) && isGTE(next, cur)) {
+        i = sameDate(prev, cur) ? j - 1 : j;
+        break;
+      } else if (isGTE(cur, next)) {
+        i = j;
+      }
+    }
+    return i;
+  };
+  const getSectionTitle = useCallback((title) => {
+    if (!title) return;
+    let sectionTitle = title;
+    if (dayFormatter) {
+      sectionTitle = dayFormatter(title);
+    } else if (dayFormat) {
+      if (useMoment) {
+        const moment = getMoment();
+        sectionTitle = moment(title).format(dayFormat);
+      } else {
+        sectionTitle = new XDate(title).toString(dayFormat);
+      }
+    }
+    if (markToday) {
+      const string = getDefaultLocale().today || todayString;
+      const today = isToday(title);
+      sectionTitle = today ? `${string}, ${sectionTitle}` : sectionTitle;
+    }
+    return sectionTitle;
+  }, []);
+  const scrollToSection = useCallback(
+    debounce(
+      (d) => {
         const sectionIndex = scrollToNextEvent ? getNextSectionIndex(d) : getSectionIndex(d);
         if (isUndefined(sectionIndex)) {
-            return;
+          return;
         }
         if (list?.current && sectionIndex !== undefined) {
-            sectionScroll.current = true; // to avoid setDate() in onViewableItemsChanged
-            _topSection.current = sections[sectionIndex]?.title;
-            list?.current.scrollToLocation({
-                animated: true,
-                sectionIndex: sectionIndex,
-                itemIndex: 1,
-                viewPosition: 0,
-                viewOffset: (constants.isAndroid ? sectionHeight.current : 0) + viewOffset
-            });
-        }
-    }, 1000, { leading: false, trailing: true }), [viewOffset, sections]);
-    const _onViewableItemsChanged = useCallback((info) => {
-        if (info?.viewableItems && !sectionScroll.current) {
-            const topSection = get(info?.viewableItems[0], 'section.title');
-            if (topSection && topSection !== _topSection.current) {
-                _topSection.current = topSection;
-                if (didScroll.current && !avoidDateUpdates) {
-                    // to avoid setDate() on first load (while setting the initial context.date value)
-                    setDate?.(_topSection.current, UpdateSources.LIST_DRAG);
-                }
-            }
-        }
-        onViewableItemsChanged?.(info);
-    }, [avoidDateUpdates, setDate, onViewableItemsChanged]);
-    const _onScroll = useCallback((event) => {
-        if (!didScroll.current) {
-            didScroll.current = true;
-            scrollToSection.cancel();
-        }
-        onScroll?.(event);
-    }, [onScroll]);
-    const _onMomentumScrollBegin = useCallback((event) => {
-        setDisabled?.(true);
-        onMomentumScrollBegin?.(event);
-    }, [onMomentumScrollBegin, setDisabled]);
-    const _onMomentumScrollEnd = useCallback((event) => {
-        // when list momentum ends AND when scrollToSection scroll ends
-        sectionScroll.current = false;
-        setDisabled?.(false);
-        onMomentumScrollEnd?.(event);
-    }, [onMomentumScrollEnd, setDisabled]);
-    const headerTextStyle = useMemo(() => [style.current.sectionText, sectionStyle], [sectionStyle]);
-    const _onScrollToIndexFailed = useCallback((info) => {
-        if (onScrollToIndexFailed) {
-            onScrollToIndexFailed(info);
-        }
-        else {
-            console.log('onScrollToIndexFailed info: ', info);
+          sectionScroll.current = true; // to avoid setDate() in onViewableItemsChanged
+          _topSection.current = sections[sectionIndex]?.title;
+          list?.current.scrollToLocation({
+            animated: true,
+            sectionIndex: sectionIndex,
+            itemIndex: 1,
+            viewPosition: 0,
+            viewOffset: (constants.isAndroid ? sectionHeight.current : 0) + viewOffset,
+          });
         }
-    }, [onScrollToIndexFailed]);
-    const onHeaderLayout = useCallback((event) => {
-        sectionHeight.current = event.nativeEvent.layout.height;
-    }, []);
-    const _renderSectionHeader = useCallback((info) => {
-        const title = info?.section?.title;
-        if (renderSectionHeader) {
-            return renderSectionHeader(title);
+      },
+      1000,
+      { leading: false, trailing: true },
+    ),
+    [viewOffset, sections],
+  );
+  const _onViewableItemsChanged = useCallback(
+    (info) => {
+      if (info?.viewableItems && !sectionScroll.current) {
+        const topSection = get(info?.viewableItems[0], 'section.title');
+        if (topSection && topSection !== _topSection.current) {
+          _topSection.current = topSection;
+          if (didScroll.current && !avoidDateUpdates) {
+            // to avoid setDate() on first load (while setting the initial context.date value)
+            setDate?.(_topSection.current, UpdateSources.LIST_DRAG);
+          }
         }
-        const headerTitle = getSectionTitle(title);
-        return <AgendaSectionHeader title={headerTitle} style={headerTextStyle} onLayout={onHeaderLayout}/>;
-    }, [headerTextStyle]);
-    const _keyExtractor = useCallback((item, index) => {
-        return isFunction(keyExtractor) ? keyExtractor(item, index) : String(index);
-    }, [keyExtractor]);
-    return (<SectionList stickySectionHeadersEnabled {...props} ref={list} keyExtractor={_keyExtractor} showsVerticalScrollIndicator={false} onViewableItemsChanged={_onViewableItemsChanged} viewabilityConfig={viewabilityConfig} renderSectionHeader={_renderSectionHeader} onScroll={_onScroll} onMomentumScrollBegin={_onMomentumScrollBegin} onMomentumScrollEnd={_onMomentumScrollEnd} onScrollToIndexFailed={_onScrollToIndexFailed}/>);
-    // _getItemLayout = (data, index) => {
-    //   return {length: constants.screenWidth, offset: constants.screenWidth * index, index};
-    // }
+      }
+      onViewableItemsChanged?.(info);
+    },
+    [avoidDateUpdates, setDate, onViewableItemsChanged],
+  );
+  const _onScroll = useCallback(
+    (event) => {
+      if (!didScroll.current) {
+        didScroll.current = true;
+        scrollToSection.cancel();
+      }
+      onScroll?.(event);
+    },
+    [onScroll],
+  );
+  const _onMomentumScrollBegin = useCallback(
+    (event) => {
+      setDisabled?.(true);
+      onMomentumScrollBegin?.(event);
+    },
+    [onMomentumScrollBegin, setDisabled],
+  );
+  const _onMomentumScrollEnd = useCallback(
+    (event) => {
+      // when list momentum ends AND when scrollToSection scroll ends
+      sectionScroll.current = false;
+      setDisabled?.(false);
+      onMomentumScrollEnd?.(event);
+    },
+    [onMomentumScrollEnd, setDisabled],
+  );
+  const headerTextStyle = useMemo(() => [style.current.sectionText, sectionStyle], [sectionStyle]);
+  const _onScrollToIndexFailed = useCallback(
+    (info) => {
+      if (onScrollToIndexFailed) {
+        onScrollToIndexFailed(info);
+      } else {
+        console.log('onScrollToIndexFailed info: ', info);
+      }
+    },
+    [onScrollToIndexFailed],
+  );
+  const onHeaderLayout = useCallback((event) => {
+    sectionHeight.current = event.nativeEvent.layout.height;
+  }, []);
+  const _renderSectionHeader = useCallback(
+    (info) => {
+      const title = info?.section?.title;
+      if (renderSectionHeader) {
+        return renderSectionHeader(title);
+      }
+      const headerTitle = getSectionTitle(title);
+      return <AgendaSectionHeader title={headerTitle} style={headerTextStyle} onLayout={onHeaderLayout} />;
+    },
+    [headerTextStyle],
+  );
+  const _keyExtractor = useCallback(
+    (item, index) => {
+      return isFunction(keyExtractor) ? keyExtractor(item, index) : String(index);
+    },
+    [keyExtractor],
+  );
+  return (
+    <SectionList
+      stickySectionHeadersEnabled
+      {...props}
+      ref={list}
+      keyExtractor={_keyExtractor}
+      showsVerticalScrollIndicator={false}
+      onViewableItemsChanged={_onViewableItemsChanged}
+      viewabilityConfig={viewabilityConfig}
+      renderSectionHeader={_renderSectionHeader}
+      onScroll={_onScroll}
+      onMomentumScrollBegin={_onMomentumScrollBegin}
+      onMomentumScrollEnd={_onMomentumScrollEnd}
+      onScrollToIndexFailed={_onScrollToIndexFailed}
+    />
+  );
+  // _getItemLayout = (data, index) => {
+  //   return {length: constants.screenWidth, offset: constants.screenWidth * index, index};
+  // }
 };
 export default AgendaList;
 AgendaList.displayName = 'AgendaList';
 AgendaList.propTypes = {
-    dayFormat: PropTypes.string,
-    dayFormatter: PropTypes.func,
-    useMoment: PropTypes.bool,
-    markToday: PropTypes.bool,
-    sectionStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),
-    avoidDateUpdates: PropTypes.bool
+  dayFormat: PropTypes.string,
+  dayFormatter: PropTypes.func,
+  useMoment: PropTypes.bool,
+  markToday: PropTypes.bool,
+  sectionStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),
+  avoidDateUpdates: PropTypes.bool,
 };
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/index.js b/node_modules/react-native-calendars/src/expandableCalendar/index.js
index fe7025d..3f2a3bd 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/index.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/index.js
@@ -1,25 +1,29 @@
+import React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
+import { AccessibilityInfo, Animated, Image, PanResponder, Text, TouchableOpacity, View } from 'react-native';
+
 import first from 'lodash/first';
 import isFunction from 'lodash/isFunction';
 import isNumber from 'lodash/isNumber';
 import throttle from 'lodash/throttle';
 import XDate from 'xdate';
-import React, { useContext, useRef, useState, useEffect, useCallback, useMemo } from 'react';
-import { AccessibilityInfo, PanResponder, Animated, View, Text, Image, TouchableOpacity } from 'react-native';
-import { page } from '../dateutils';
-import { parseDate, toMarkingFormat } from '../interface';
+
+import Context from './Context';
+import WeekCalendar from './WeekCalendar';
+import { UpdateSources } from './commons';
 import styleConstructor, { HEADER_HEIGHT, KNOB_CONTAINER_HEIGHT } from './style';
-import WeekDaysNames from '../commons/WeekDaysNames';
+import Week from './week';
+
 import Calendar from '../calendar';
 import CalendarList from '../calendar-list';
-import Week from './week';
-import WeekCalendar from './WeekCalendar';
-import Context from './Context';
+import WeekDaysNames from '../commons/WeekDaysNames';
 import constants from '../commons/constants';
-import { UpdateSources } from './commons';
+import { page } from '../dateutils';
+import { parseDate, toMarkingFormat } from '../interface';
+
 export var Positions;
 (function (Positions) {
-    Positions["CLOSED"] = "closed";
-    Positions["OPEN"] = "open";
+  Positions['CLOSED'] = 'closed';
+  Positions['OPEN'] = 'open';
 })(Positions || (Positions = {}));
 const SPEED = 20;
 const BOUNCINESS = 6;
@@ -31,18 +35,18 @@ const LEFT_ARROW = require('../calendar/img/previous.png');
 const RIGHT_ARROW = require('../calendar/img/next.png');
 const knobHitSlop = { left: 10, right: 10, top: 10, bottom: 10 };
 const headerStyleOverride = {
-    stylesheet: {
-        calendar: {
-            header: {
-                week: {
-                    marginTop: 7,
-                    marginBottom: -4,
-                    flexDirection: 'row',
-                    justifyContent: 'space-around'
-                }
-            }
-        }
-    }
+  stylesheet: {
+    calendar: {
+      header: {
+        week: {
+          marginTop: 7,
+          marginBottom: -4,
+          flexDirection: 'row',
+          justifyContent: 'space-around',
+        },
+      },
+    },
+  },
 };
 /**
  * @description: Expandable calendar component
@@ -52,373 +56,499 @@ const headerStyleOverride = {
  * @example: https://github.com/wix/react-native-calendars/blob/master/example/src/screens/expandableCalendar.js
  */
 const ExpandableCalendar = (props) => {
-    const { date, setDate, numberOfDays, timelineLeftInset } = useContext(Context);
-    const { 
+  const { date, setDate, numberOfDays, timelineLeftInset } = useContext(Context);
+  const {
     /** ExpandableCalendar props */
-    initialPosition = Positions.CLOSED, onCalendarToggled, disablePan, hideKnob = numberOfDays && numberOfDays > 1, leftArrowImageSource = LEFT_ARROW, rightArrowImageSource = RIGHT_ARROW, allowShadow = true, disableWeekScroll, openThreshold = PAN_GESTURE_THRESHOLD, closeThreshold = PAN_GESTURE_THRESHOLD, closeOnDayPress = true, 
+    initialPosition = Positions.CLOSED,
+    onCalendarToggled,
+    disablePan,
+    hideKnob = numberOfDays && numberOfDays > 1,
+    leftArrowImageSource = LEFT_ARROW,
+    rightArrowImageSource = RIGHT_ARROW,
+    allowShadow = true,
+    disableWeekScroll,
+    openThreshold = PAN_GESTURE_THRESHOLD,
+    closeThreshold = PAN_GESTURE_THRESHOLD,
+    closeOnDayPress = true,
     /** CalendarList props */
-    horizontal = true, calendarStyle, theme, style: propsStyle, firstDay = 0, onDayPress, hideArrows, onPressArrowLeft, onPressArrowRight, renderArrow, testID, ...others } = props;
-    const [screenReaderEnabled, setScreenReaderEnabled] = useState(false);
-    /** Date */
-    const getYear = (date) => {
-        const d = new XDate(date);
-        return d.getFullYear();
-    };
-    const getMonth = (date) => {
-        const d = new XDate(date);
-        return d.getMonth() + 1; // getMonth() returns month's index' (0-11)
-    };
-    const visibleMonth = useRef(getMonth(date));
-    const visibleYear = useRef(getYear(date));
-    const isLaterDate = (date1, date2) => {
-        if (date1 && date2) {
-            if (date1.year > getYear(date2)) {
-                return true;
-            }
-            if (date1.year === getYear(date2)) {
-                if (date1.month > getMonth(date2)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    };
-    useEffect(() => {
-        // date was changed from AgendaList, arrows or scroll
-        scrollToDate(date);
-    }, [date]);
-    /** Number of weeks */
-    const getNumberOfWeeksInMonth = (month) => {
-        const days = page(new XDate(month), firstDay);
-        return days.length / 7;
-    };
-    const numberOfWeeks = useRef(getNumberOfWeeksInMonth(date));
-    /** Position */
-    const [position, setPosition] = useState(numberOfDays ? Positions.CLOSED : initialPosition);
-    const isOpen = position === Positions.OPEN;
-    const getOpenHeight = () => {
-        if (!horizontal) {
-            return Math.max(constants.screenHeight, constants.screenWidth);
-        }
-        return CLOSED_HEIGHT + (WEEK_HEIGHT * (numberOfWeeks.current - 1)) + (hideKnob ? 12 : KNOB_CONTAINER_HEIGHT) + (constants.isAndroid ? 3 : 0);
-    };
-    const openHeight = useRef(getOpenHeight());
-    const closedHeight = useMemo(() => CLOSED_HEIGHT + (hideKnob || Number(numberOfDays) > 1 ? 0 : KNOB_CONTAINER_HEIGHT), [numberOfDays, hideKnob]);
-    const startHeight = useMemo(() => isOpen ? openHeight.current : closedHeight, [closedHeight, isOpen]);
-    const _height = useRef(startHeight);
-    const deltaY = useMemo(() => new Animated.Value(startHeight), [startHeight]);
-    const headerDeltaY = useRef(new Animated.Value(isOpen ? -HEADER_HEIGHT : 0));
-    useEffect(() => {
-        _height.current = startHeight;
-        deltaY.setValue(startHeight);
-    }, [startHeight]);
-    useEffect(() => {
-        if (numberOfDays) {
-            setPosition(Positions.CLOSED);
-        }
-    }, [numberOfDays]);
-    /** Components' refs */
-    const wrapper = useRef();
-    const calendarList = useRef();
-    const header = useRef();
-    const weekCalendarWrapper = useRef();
-    /** Styles */
-    const style = useRef(styleConstructor(theme));
-    const themeObject = Object.assign(headerStyleOverride, theme);
-    const _wrapperStyles = useRef({ style: { height: startHeight } });
-    const _headerStyles = { style: { top: isOpen ? -HEADER_HEIGHT : 0 } };
-    const _weekCalendarStyles = { style: { opacity: isOpen ? 0 : 1 } };
-    const shouldHideArrows = !horizontal ? true : hideArrows || false;
-    const updateNativeStyles = () => {
-        wrapper?.current?.setNativeProps(_wrapperStyles.current);
-        if (!horizontal) {
-            header?.current?.setNativeProps(_headerStyles);
-        }
-        else {
-            weekCalendarWrapper?.current?.setNativeProps(_weekCalendarStyles);
-        }
-    };
-    const weekDaysStyle = useMemo(() => {
-        const leftPaddings = calendarStyle?.paddingLeft;
-        const rightPaddings = calendarStyle?.paddingRight;
-        return [
-            style.current.weekDayNames,
-            {
-                paddingLeft: isNumber(leftPaddings) ? leftPaddings + 6 : DAY_NAMES_PADDING,
-                paddingRight: isNumber(rightPaddings) ? rightPaddings + 6 : DAY_NAMES_PADDING
-            }
-        ];
-    }, [calendarStyle]);
-    const animatedHeaderStyle = useMemo(() => {
-        return [style.current.header, { height: HEADER_HEIGHT + 10, top: headerDeltaY.current }];
-    }, [headerDeltaY.current]);
-    const weekCalendarStyle = useMemo(() => {
-        return [style.current.weekContainer, isOpen ? style.current.hidden : style.current.visible];
-    }, [isOpen]);
-    const containerStyle = useMemo(() => {
-        return [allowShadow && style.current.containerShadow, propsStyle];
-    }, [allowShadow, propsStyle]);
-    const wrapperStyle = useMemo(() => {
-        return { height: deltaY };
-    }, [deltaY]);
-    const numberOfDaysHeaderStyle = useMemo(() => {
-        if (numberOfDays && numberOfDays > 1) {
-            return { paddingHorizontal: 0 };
-        }
-    }, [numberOfDays]);
-    const _headerStyle = useMemo(() => {
-        return [numberOfDaysHeaderStyle, props.headerStyle];
-    }, [props.headerStyle, numberOfDaysHeaderStyle]);
-    /** AccessibilityInfo */
-    useEffect(() => {
-        if (AccessibilityInfo) {
-            if (AccessibilityInfo.isScreenReaderEnabled) {
-                AccessibilityInfo.isScreenReaderEnabled().then(handleScreenReaderStatus);
-                //@ts-expect-error
-            }
-            else if (AccessibilityInfo.fetch) {
-                // Support for older RN versions
-                //@ts-expect-error
-                AccessibilityInfo.fetch().then(handleScreenReaderStatus);
-            }
-        }
-    }, []);
-    const handleScreenReaderStatus = (screenReaderEnabled) => {
-        setScreenReaderEnabled(screenReaderEnabled);
-    };
-    /** Scroll */
-    const scrollToDate = (date) => {
-        if (!horizontal) {
-            calendarList?.current?.scrollToDay(date, 0, true);
-        }
-        else if (getYear(date) !== visibleYear.current || getMonth(date) !== visibleMonth.current) {
-            // don't scroll if the month is already visible
-            calendarList?.current?.scrollToMonth(date);
-        }
-    };
-    const scrollPage = useCallback((next) => {
-        if (horizontal) {
-            const d = parseDate(date);
-            if (isOpen) {
-                d.setDate(1);
-                d.addMonths(next ? 1 : -1);
-            }
-            else {
-                let dayOfTheWeek = d.getDay();
-                if (dayOfTheWeek < firstDay && firstDay > 0) {
-                    dayOfTheWeek = 7 + dayOfTheWeek;
-                }
-                if (numberOfDays) {
-                    const daysToAdd = numberOfDays <= 1 ? 7 : numberOfDays;
-                    d.addDays(next ? daysToAdd : -daysToAdd);
-                }
-                else {
-                    const firstDayOfWeek = (next ? 7 : -7) - dayOfTheWeek + firstDay;
-                    d.addDays(firstDayOfWeek);
-                }
-            }
-            setDate?.(toMarkingFormat(d), UpdateSources.PAGE_SCROLL);
-        }
-    }, [horizontal, isOpen, firstDay, numberOfDays, setDate, date]);
-    /** Pan Gesture */
-    const handleMoveShouldSetPanResponder = (_, gestureState) => {
-        if (disablePan) {
-            return false;
-        }
-        if (!horizontal && isOpen) {
-            // disable pan detection when vertical calendar is open to allow calendar scroll
-            return false;
-        }
-        if (!isOpen && gestureState.dy < 0) {
-            // disable pan detection to limit to closed height
-            return false;
-        }
-        return gestureState.dy > 5 || gestureState.dy < -5;
-    };
-    const handlePanResponderMove = (_, gestureState) => {
-        // limit min height to closed height and max to open height
-        _wrapperStyles.current.style.height = Math.min(Math.max(closedHeight, _height.current + gestureState.dy), openHeight.current);
-        if (!horizontal) {
-            // vertical CalenderList header
-            _headerStyles.style.top = Math.min(Math.max(-gestureState.dy, -HEADER_HEIGHT), 0);
-        }
-        else {
-            // horizontal Week view
-            if (!isOpen) {
-                _weekCalendarStyles.style.opacity = Math.min(1, Math.max(1 - gestureState.dy / 100, 0));
-            }
-            else if (gestureState.dy < 0) {
-                _weekCalendarStyles.style.opacity = Math.max(0, Math.min(Math.abs(gestureState.dy / 200), 1));
-            }
-        }
-        updateNativeStyles();
-    };
-    const handlePanResponderEnd = () => {
-        _height.current = Number(_wrapperStyles.current.style.height);
-        bounceToPosition();
-    };
-    const numberOfDaysCondition = useMemo(() => {
-        return !numberOfDays || numberOfDays && numberOfDays <= 1;
-    }, [numberOfDays]);
-    const panResponder = useMemo(() => numberOfDaysCondition ? PanResponder.create({
-        onMoveShouldSetPanResponder: handleMoveShouldSetPanResponder,
-        onPanResponderMove: handlePanResponderMove,
-        onPanResponderRelease: handlePanResponderEnd,
-        onPanResponderTerminate: handlePanResponderEnd
-    }) : PanResponder.create({}), [numberOfDays, position]);
-    /** Animated */
-    const bounceToPosition = (toValue = 0) => {
-        if (!disablePan) {
-            const threshold = isOpen ? openHeight.current - closeThreshold : closedHeight + openThreshold;
-            let _isOpen = _height.current >= threshold;
-            const newValue = _isOpen ? openHeight.current : closedHeight;
-            deltaY.setValue(_height.current); // set the start position for the animated value
-            _height.current = toValue || newValue;
-            _isOpen = _height.current >= threshold; // re-check after _height.current was set
-            resetWeekCalendarOpacity(_isOpen);
-            Animated.spring(deltaY, {
-                toValue: _height.current,
-                speed: SPEED,
-                bounciness: BOUNCINESS,
-                useNativeDriver: false
-            }).start(() => {
-                onCalendarToggled?.(_isOpen);
-                setPosition(() => _height.current === closedHeight ? Positions.CLOSED : Positions.OPEN);
-            });
-            closeHeader(_isOpen);
-        }
-    };
-    const resetWeekCalendarOpacity = async (isOpen) => {
-        _weekCalendarStyles.style.opacity = isOpen ? 0 : 1;
-        updateNativeStyles();
-    };
-    const closeHeader = (isOpen) => {
-        headerDeltaY.current.setValue(Number(_headerStyles.style.top)); // set the start position for the animated value
-        if (!horizontal && !isOpen) {
-            Animated.spring(headerDeltaY.current, {
-                toValue: 0,
-                speed: SPEED / 10,
-                bounciness: 1,
-                useNativeDriver: false
-            }).start();
-        }
-    };
-    const closeCalendar = useCallback(() => {
-        setTimeout(() => {
-            // to allows setDate to be completed
-            if (isOpen) {
-                bounceToPosition(closedHeight);
-            }
-        }, 0);
-    }, [isOpen, closedHeight]);
-    const toggleCalendarPosition = useCallback(() => {
-        bounceToPosition(isOpen ? closedHeight : openHeight.current);
-    }, [isOpen, bounceToPosition, closedHeight]);
-    /** Events */
-    const _onPressArrowLeft = useCallback((method, month) => {
-        onPressArrowLeft?.(method, month);
-        scrollPage(false);
-    }, [onPressArrowLeft, scrollPage]);
-    const _onPressArrowRight = useCallback((method, month) => {
-        onPressArrowRight?.(method, month);
-        scrollPage(true);
-    }, [onPressArrowRight, scrollPage]);
-    const _onDayPress = useCallback((value) => {
-        if (numberOfDaysCondition) {
-            setDate?.(value.dateString, UpdateSources.DAY_PRESS);
+    horizontal = true,
+    calendarStyle,
+    theme,
+    style: propsStyle,
+    firstDay = 0,
+    onDayPress,
+    hideArrows,
+    onPressArrowLeft,
+    onPressArrowRight,
+    renderArrow,
+    testID,
+    ...others
+  } = props;
+  const [screenReaderEnabled, setScreenReaderEnabled] = useState(false);
+  /** Date */
+  const getYear = (date) => {
+    const d = new XDate(date);
+    return d.getFullYear();
+  };
+  const getMonth = (date) => {
+    const d = new XDate(date);
+    return d.getMonth() + 1; // getMonth() returns month's index' (0-11)
+  };
+  const visibleMonth = useRef(getMonth(date));
+  const visibleYear = useRef(getYear(date));
+  const isLaterDate = (date1, date2) => {
+    if (date1 && date2) {
+      if (date1.year > getYear(date2)) {
+        return true;
+      }
+      if (date1.year === getYear(date2)) {
+        if (date1.month > getMonth(date2)) {
+          return true;
         }
-        if (closeOnDayPress) {
-            closeCalendar();
+      }
+    }
+    return false;
+  };
+  useEffect(() => {
+    // date was changed from AgendaList, arrows or scroll
+    scrollToDate(date);
+  }, [date]);
+  /** Number of weeks */
+  const getNumberOfWeeksInMonth = (month) => {
+    const days = page(new XDate(month), firstDay);
+    return days.length / 7;
+  };
+  const numberOfWeeks = useRef(getNumberOfWeeksInMonth(date));
+  /** Position */
+  const [position, setPosition] = useState(numberOfDays ? Positions.CLOSED : initialPosition);
+  const isOpen = position === Positions.OPEN;
+  const getOpenHeight = () => {
+    if (!horizontal) {
+      return Math.max(constants.screenHeight, constants.screenWidth);
+    }
+    return (
+      CLOSED_HEIGHT +
+      WEEK_HEIGHT * (numberOfWeeks.current - 1) +
+      (hideKnob ? 12 : KNOB_CONTAINER_HEIGHT) +
+      (constants.isAndroid ? 3 : 0)
+    );
+  };
+  const openHeight = useRef(getOpenHeight());
+  const closedHeight = useMemo(
+    () => CLOSED_HEIGHT + (hideKnob || Number(numberOfDays) > 1 ? 0 : KNOB_CONTAINER_HEIGHT),
+    [numberOfDays, hideKnob],
+  );
+  const startHeight = useMemo(() => (isOpen ? openHeight.current : closedHeight), [closedHeight, isOpen]);
+  const _height = useRef(startHeight);
+  const deltaY = useMemo(() => new Animated.Value(startHeight), [startHeight]);
+  const headerDeltaY = useRef(new Animated.Value(isOpen ? -HEADER_HEIGHT : 0));
+  useEffect(() => {
+    _height.current = startHeight;
+    deltaY.setValue(startHeight);
+  }, [startHeight]);
+  useEffect(() => {
+    if (numberOfDays) {
+      setPosition(Positions.CLOSED);
+    }
+  }, [numberOfDays]);
+  /** Components' refs */
+  const wrapper = useRef();
+  const calendarList = useRef();
+  const header = useRef();
+  const weekCalendarWrapper = useRef();
+  /** Styles */
+  const style = useRef(styleConstructor(theme));
+  const themeObject = Object.assign(headerStyleOverride, theme);
+  const _wrapperStyles = useRef({ style: { height: startHeight } });
+  const _headerStyles = { style: { top: isOpen ? -HEADER_HEIGHT : 0 } };
+  const _weekCalendarStyles = { style: { opacity: isOpen ? 0 : 1 } };
+  const shouldHideArrows = !horizontal ? true : hideArrows || false;
+  const updateNativeStyles = () => {
+    wrapper?.current?.setNativeProps(_wrapperStyles.current);
+    if (!horizontal) {
+      header?.current?.setNativeProps(_headerStyles);
+    } else {
+      weekCalendarWrapper?.current?.setNativeProps(_weekCalendarStyles);
+    }
+  };
+  const weekDaysStyle = useMemo(() => {
+    const leftPaddings = calendarStyle?.paddingLeft;
+    const rightPaddings = calendarStyle?.paddingRight;
+    return [
+      style.current.weekDayNames,
+      {
+        paddingLeft: isNumber(leftPaddings) ? leftPaddings + 6 : DAY_NAMES_PADDING,
+        paddingRight: isNumber(rightPaddings) ? rightPaddings + 6 : DAY_NAMES_PADDING,
+      },
+    ];
+  }, [calendarStyle]);
+  const animatedHeaderStyle = useMemo(() => {
+    return [style.current.header, { height: HEADER_HEIGHT + 10, top: headerDeltaY.current }];
+  }, [headerDeltaY.current]);
+  const weekCalendarStyle = useMemo(() => {
+    return [style.current.weekContainer, isOpen ? style.current.hidden : style.current.visible];
+  }, [isOpen]);
+  const containerStyle = useMemo(() => {
+    return [allowShadow && style.current.containerShadow, propsStyle];
+  }, [allowShadow, propsStyle]);
+  const wrapperStyle = useMemo(() => {
+    return { height: deltaY };
+  }, [deltaY]);
+  const numberOfDaysHeaderStyle = useMemo(() => {
+    if (numberOfDays && numberOfDays > 1) {
+      return { paddingHorizontal: 0 };
+    }
+  }, [numberOfDays]);
+  const _headerStyle = useMemo(() => {
+    return [numberOfDaysHeaderStyle, props.headerStyle];
+  }, [props.headerStyle, numberOfDaysHeaderStyle]);
+  /** AccessibilityInfo */
+  useEffect(() => {
+    if (AccessibilityInfo) {
+      if (AccessibilityInfo.isScreenReaderEnabled) {
+        AccessibilityInfo.isScreenReaderEnabled().then(handleScreenReaderStatus);
+        //@ts-expect-error
+      } else if (AccessibilityInfo.fetch) {
+        // Support for older RN versions
+        //@ts-expect-error
+        AccessibilityInfo.fetch().then(handleScreenReaderStatus);
+      }
+    }
+  }, []);
+  const handleScreenReaderStatus = (screenReaderEnabled) => {
+    setScreenReaderEnabled(screenReaderEnabled);
+  };
+  /** Scroll */
+  const scrollToDate = (date) => {
+    if (!horizontal) {
+      calendarList?.current?.scrollToDay(date, 0, true);
+    } else if (getYear(date) !== visibleYear.current || getMonth(date) !== visibleMonth.current) {
+      // don't scroll if the month is already visible
+      calendarList?.current?.scrollToMonth(date);
+    }
+  };
+  const scrollPage = useCallback(
+    (next) => {
+      if (horizontal) {
+        const d = parseDate(date);
+        if (isOpen) {
+          d.setDate(1);
+          d.addMonths(next ? 1 : -1);
+        } else {
+          let dayOfTheWeek = d.getDay();
+          if (dayOfTheWeek < firstDay && firstDay > 0) {
+            dayOfTheWeek = 7 + dayOfTheWeek;
+          }
+          if (numberOfDays) {
+            const daysToAdd = numberOfDays <= 1 ? 7 : numberOfDays;
+            d.addDays(next ? daysToAdd : -daysToAdd);
+          } else {
+            const firstDayOfWeek = (next ? 7 : -7) - dayOfTheWeek + firstDay;
+            d.addDays(firstDayOfWeek);
+          }
         }
-        onDayPress?.(value);
-    }, [onDayPress, closeOnDayPress, closeCalendar, numberOfDaysCondition]);
-    const onVisibleMonthsChange = useCallback(throttle((value) => {
+        setDate?.(toMarkingFormat(d), UpdateSources.PAGE_SCROLL);
+      }
+    },
+    [horizontal, isOpen, firstDay, numberOfDays, setDate, date],
+  );
+  /** Pan Gesture */
+  const handleMoveShouldSetPanResponder = (_, gestureState) => {
+    if (disablePan) {
+      return false;
+    }
+    if (!horizontal && isOpen) {
+      // disable pan detection when vertical calendar is open to allow calendar scroll
+      return false;
+    }
+    if (!isOpen && gestureState.dy < 0) {
+      // disable pan detection to limit to closed height
+      return false;
+    }
+    return gestureState.dy > 5 || gestureState.dy < -5;
+  };
+  const handlePanResponderMove = (_, gestureState) => {
+    // limit min height to closed height and max to open height
+    _wrapperStyles.current.style.height = Math.min(
+      Math.max(closedHeight, _height.current + gestureState.dy),
+      openHeight.current,
+    );
+    if (!horizontal) {
+      // vertical CalenderList header
+      _headerStyles.style.top = Math.min(Math.max(-gestureState.dy, -HEADER_HEIGHT), 0);
+    } else {
+      // horizontal Week view
+      if (!isOpen) {
+        _weekCalendarStyles.style.opacity = Math.min(1, Math.max(1 - gestureState.dy / 100, 0));
+      } else if (gestureState.dy < 0) {
+        _weekCalendarStyles.style.opacity = Math.max(0, Math.min(Math.abs(gestureState.dy / 200), 1));
+      }
+    }
+    updateNativeStyles();
+  };
+  const handlePanResponderEnd = () => {
+    _height.current = Number(_wrapperStyles.current.style.height);
+    bounceToPosition();
+  };
+  const numberOfDaysCondition = useMemo(() => {
+    return !numberOfDays || (numberOfDays && numberOfDays <= 1);
+  }, [numberOfDays]);
+  const panResponder = useMemo(
+    () =>
+      numberOfDaysCondition
+        ? PanResponder.create({
+            onMoveShouldSetPanResponder: handleMoveShouldSetPanResponder,
+            onPanResponderMove: handlePanResponderMove,
+            onPanResponderRelease: handlePanResponderEnd,
+            onPanResponderTerminate: handlePanResponderEnd,
+          })
+        : PanResponder.create({}),
+    [numberOfDays, position],
+  );
+  /** Animated */
+  const bounceToPosition = (toValue = 0) => {
+    if (!disablePan) {
+      const threshold = isOpen ? openHeight.current - closeThreshold : closedHeight + openThreshold;
+      let _isOpen = _height.current >= threshold;
+      const newValue = _isOpen ? openHeight.current : closedHeight;
+      deltaY.setValue(_height.current); // set the start position for the animated value
+      _height.current = toValue || newValue;
+      _isOpen = _height.current >= threshold; // re-check after _height.current was set
+      resetWeekCalendarOpacity(_isOpen);
+      Animated.spring(deltaY, {
+        toValue: _height.current,
+        speed: SPEED,
+        bounciness: BOUNCINESS,
+        useNativeDriver: false,
+      }).start(() => {
+        onCalendarToggled?.(_isOpen);
+        setPosition(() => (_height.current === closedHeight ? Positions.CLOSED : Positions.OPEN));
+      });
+      closeHeader(_isOpen);
+    }
+  };
+  const resetWeekCalendarOpacity = async (isOpen) => {
+    _weekCalendarStyles.style.opacity = isOpen ? 0 : 1;
+    updateNativeStyles();
+  };
+  const closeHeader = (isOpen) => {
+    headerDeltaY.current.setValue(Number(_headerStyles.style.top)); // set the start position for the animated value
+    if (!horizontal && !isOpen) {
+      Animated.spring(headerDeltaY.current, {
+        toValue: 0,
+        speed: SPEED / 10,
+        bounciness: 1,
+        useNativeDriver: false,
+      }).start();
+    }
+  };
+  const closeCalendar = useCallback(() => {
+    setTimeout(() => {
+      // to allows setDate to be completed
+      if (isOpen) {
+        bounceToPosition(closedHeight);
+      }
+    }, 0);
+  }, [isOpen, closedHeight]);
+  const toggleCalendarPosition = useCallback(() => {
+    bounceToPosition(isOpen ? closedHeight : openHeight.current);
+  }, [isOpen, bounceToPosition, closedHeight]);
+  /** Events */
+  const _onPressArrowLeft = useCallback(
+    (method, month) => {
+      onPressArrowLeft?.(method, month);
+      scrollPage(false);
+    },
+    [onPressArrowLeft, scrollPage],
+  );
+  const _onPressArrowRight = useCallback(
+    (method, month) => {
+      onPressArrowRight?.(method, month);
+      scrollPage(true);
+    },
+    [onPressArrowRight, scrollPage],
+  );
+  const _onDayPress = useCallback(
+    (value) => {
+      if (numberOfDaysCondition) {
+        setDate?.(value.dateString, UpdateSources.DAY_PRESS);
+      }
+      if (closeOnDayPress) {
+        closeCalendar();
+      }
+      onDayPress?.(value);
+    },
+    [onDayPress, closeOnDayPress, closeCalendar, numberOfDaysCondition],
+  );
+  const onVisibleMonthsChange = useCallback(
+    throttle(
+      (value) => {
         const newDate = first(value);
         if (newDate) {
-            const month = newDate.month;
-            if (month && visibleMonth.current !== month) {
-                visibleMonth.current = month;
-                const year = newDate.year;
-                if (year) {
-                    visibleYear.current = year;
-                }
-                // for horizontal scroll
-                if (visibleMonth.current !== getMonth(date)) {
-                    const next = isLaterDate(newDate, date);
-                    scrollPage(next);
-                }
-                // updating openHeight
-                setTimeout(() => {
-                    // to wait for setDate() call in horizontal scroll (scrollPage())
-                    const _numberOfWeeks = getNumberOfWeeksInMonth(newDate.dateString);
-                    if (_numberOfWeeks !== numberOfWeeks.current) {
-                        numberOfWeeks.current = _numberOfWeeks;
-                        openHeight.current = getOpenHeight();
-                        if (isOpen) {
-                            bounceToPosition(openHeight.current);
-                        }
-                    }
-                }, 0);
+          const month = newDate.month;
+          if (month && visibleMonth.current !== month) {
+            visibleMonth.current = month;
+            const year = newDate.year;
+            if (year) {
+              visibleYear.current = year;
             }
+            // for horizontal scroll
+            if (visibleMonth.current !== getMonth(date)) {
+              const next = isLaterDate(newDate, date);
+              scrollPage(next);
+            }
+            // updating openHeight
+            setTimeout(() => {
+              // to wait for setDate() call in horizontal scroll (scrollPage())
+              const _numberOfWeeks = getNumberOfWeeksInMonth(newDate.dateString);
+              if (_numberOfWeeks !== numberOfWeeks.current) {
+                numberOfWeeks.current = _numberOfWeeks;
+                openHeight.current = getOpenHeight();
+                if (isOpen) {
+                  bounceToPosition(openHeight.current);
+                }
+              }
+            }, 0);
+          }
         }
-    }, 100, { trailing: true, leading: false }), [date, scrollPage]);
-    /** Renders */
-    const _renderArrow = useCallback((direction) => {
-        if (isFunction(renderArrow)) {
-            return renderArrow(direction);
-        }
-        return (<Image source={direction === 'right' ? rightArrowImageSource : leftArrowImageSource} style={style.current.arrowImage} testID={`${testID}.${direction}Arrow`}/>);
-    }, [renderArrow, rightArrowImageSource, leftArrowImageSource, testID]);
-    const renderWeekDaysNames = () => {
-        return (<View style={weekDaysStyle}>
-        <WeekDaysNames firstDay={firstDay} style={style.current.dayHeader}/>
-      </View>);
-    };
-    const renderAnimatedHeader = () => {
-        const monthYear = new XDate(date)?.toString('MMMM yyyy');
-        return (<Animated.View ref={header} style={animatedHeaderStyle} pointerEvents={'none'}>
+      },
+      100,
+      { trailing: true, leading: false },
+    ),
+    [date, scrollPage],
+  );
+  /** Renders */
+  const _renderArrow = useCallback(
+    (direction) => {
+      if (isFunction(renderArrow)) {
+        return renderArrow(direction);
+      }
+      return (
+        <Image
+          source={direction === 'right' ? rightArrowImageSource : leftArrowImageSource}
+          style={style.current.arrowImage}
+          testID={`${testID}.${direction}Arrow`}
+        />
+      );
+    },
+    [renderArrow, rightArrowImageSource, leftArrowImageSource, testID],
+  );
+  const renderWeekDaysNames = () => {
+    return (
+      <View style={weekDaysStyle}>
+        <WeekDaysNames firstDay={firstDay} style={style.current.dayHeader} />
+      </View>
+    );
+  };
+  const renderAnimatedHeader = () => {
+    const monthYear = new XDate(date)?.toString('MMMM yyyy');
+    return (
+      <Animated.View ref={header} style={animatedHeaderStyle} pointerEvents={'none'}>
         <Text allowFontScaling={false} style={style.current.headerTitle}>
           {monthYear}
         </Text>
         {renderWeekDaysNames()}
-      </Animated.View>);
-    };
-    const renderKnob = () => {
-        return (<View style={style.current.knobContainer} pointerEvents={'box-none'}>
-        <TouchableOpacity style={style.current.knob} testID={`${testID}.knob`} onPress={toggleCalendarPosition} hitSlop={knobHitSlop} /* activeOpacity={isOpen ? undefined : 1} *//>
-      </View>);
-    };
-    const renderWeekCalendar = () => {
-        const WeekComponent = disableWeekScroll ? Week : WeekCalendar;
-        return (<Animated.View ref={weekCalendarWrapper} style={weekCalendarStyle} pointerEvents={isOpen ? 'none' : 'auto'}>
-        <WeekComponent testID={`${testID}.weekCalendar`} firstDay={firstDay} {...others} allowShadow={disableWeekScroll ? undefined : false} current={disableWeekScroll ? date : undefined} theme={themeObject} style={calendarStyle} hideDayNames={true} onDayPress={_onDayPress} accessibilityElementsHidden // iOS
-         importantForAccessibility={'no-hide-descendants'} // Android
+      </Animated.View>
+    );
+  };
+  const renderKnob = () => {
+    return (
+      <View style={style.current.knobContainer} pointerEvents={'box-none'}>
+        <TouchableOpacity
+          style={style.current.knob}
+          testID={`${testID}.knob`}
+          onPress={toggleCalendarPosition}
+          hitSlop={knobHitSlop} /* activeOpacity={isOpen ? undefined : 1} */
+        />
+      </View>
+    );
+  };
+  const renderWeekCalendar = () => {
+    const WeekComponent = disableWeekScroll ? Week : WeekCalendar;
+    return (
+      <Animated.View ref={weekCalendarWrapper} style={weekCalendarStyle} pointerEvents={isOpen ? 'none' : 'auto'}>
+        <WeekComponent
+          testID={`${testID}.weekCalendar`}
+          firstDay={firstDay}
+          {...others}
+          allowShadow={disableWeekScroll ? undefined : false}
+          current={disableWeekScroll ? date : undefined}
+          theme={themeObject}
+          style={calendarStyle}
+          hideDayNames={true}
+          onDayPress={_onDayPress}
+          accessibilityElementsHidden // iOS
+          importantForAccessibility={'no-hide-descendants'} // Android
+        />
+      </Animated.View>
+    );
+  };
+  const renderCalendarList = () => {
+    return (
+      <CalendarList
+        testID={`${testID}.calendarList`}
+        horizontal={horizontal}
+        firstDay={firstDay}
+        calendarStyle={calendarStyle}
+        {...others}
+        current={date}
+        theme={themeObject}
+        ref={calendarList}
+        onDayPress={_onDayPress}
+        onVisibleMonthsChange={onVisibleMonthsChange}
+        pagingEnabled
+        scrollEnabled={isOpen}
+        hideArrows={shouldHideArrows}
+        onPressArrowLeft={_onPressArrowLeft}
+        onPressArrowRight={_onPressArrowRight}
+        hideExtraDays={!horizontal && isOpen}
+        renderArrow={_renderArrow}
+        staticHeader
+        numberOfDays={numberOfDays}
+        headerStyle={_headerStyle}
+        timelineLeftInset={timelineLeftInset}
+        context={useContext(Context)}
+      />
+    );
+  };
+  return (
+    <View testID={testID} style={containerStyle}>
+      {screenReaderEnabled ? (
+        <Calendar
+          testID={`${testID}.calendarAccessible`}
+          {...others}
+          theme={themeObject}
+          onDayPress={_onDayPress}
+          hideExtraDays
+          renderArrow={_renderArrow}
         />
-      </Animated.View>);
-    };
-    const renderCalendarList = () => {
-        return (<CalendarList testID={`${testID}.calendarList`} horizontal={horizontal} firstDay={firstDay} calendarStyle={calendarStyle} {...others} current={date} theme={themeObject} ref={calendarList} onDayPress={_onDayPress} onVisibleMonthsChange={onVisibleMonthsChange} pagingEnabled scrollEnabled={isOpen} hideArrows={shouldHideArrows} onPressArrowLeft={_onPressArrowLeft} onPressArrowRight={_onPressArrowRight} hideExtraDays={!horizontal && isOpen} renderArrow={_renderArrow} staticHeader numberOfDays={numberOfDays} headerStyle={_headerStyle} timelineLeftInset={timelineLeftInset} context={useContext(Context)}/>);
-    };
-    return (<View testID={testID} style={containerStyle}>
-      {screenReaderEnabled ? (<Calendar testID={`${testID}.calendarAccessible`} {...others} theme={themeObject} onDayPress={_onDayPress} hideExtraDays renderArrow={_renderArrow}/>) : (<Animated.View testID={`${testID}.expandableContainer`} ref={wrapper} style={wrapperStyle} {...panResponder.panHandlers}>
+      ) : (
+        <Animated.View
+          testID={`${testID}.expandableContainer`}
+          ref={wrapper}
+          style={wrapperStyle}
+          {...panResponder.panHandlers}
+        >
           {renderCalendarList()}
           {renderWeekCalendar()}
           {!hideKnob && renderKnob()}
           {!horizontal && renderAnimatedHeader()}
-        </Animated.View>)}
-    </View>);
+        </Animated.View>
+      )}
+    </View>
+  );
 };
 export default ExpandableCalendar;
 ExpandableCalendar.displayName = 'ExpandableCalendar';
 ExpandableCalendar.defaultProps = {
-    horizontal: true,
-    initialPosition: Positions.CLOSED,
-    firstDay: 0,
-    leftArrowImageSource: LEFT_ARROW,
-    rightArrowImageSource: RIGHT_ARROW,
-    allowShadow: true,
-    openThreshold: PAN_GESTURE_THRESHOLD,
-    closeThreshold: PAN_GESTURE_THRESHOLD,
-    closeOnDayPress: true
+  horizontal: true,
+  initialPosition: Positions.CLOSED,
+  firstDay: 0,
+  leftArrowImageSource: LEFT_ARROW,
+  rightArrowImageSource: RIGHT_ARROW,
+  allowShadow: true,
+  openThreshold: PAN_GESTURE_THRESHOLD,
+  closeThreshold: PAN_GESTURE_THRESHOLD,
+  closeOnDayPress: true,
 };
 ExpandableCalendar.positions = Positions;
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/style.js b/node_modules/react-native-calendars/src/expandableCalendar/style.js
index 775ff1c..b8fde57 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/style.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/style.js
@@ -1,170 +1,162 @@
-import { StyleSheet, Platform } from 'react-native';
-import * as defaultStyle from '../style';
+import { Platform, StyleSheet } from 'react-native';
+
 import constants from '../commons/constants';
+import * as defaultStyle from '../style';
+
 export const HEADER_HEIGHT = 68;
 export const KNOB_CONTAINER_HEIGHT = 24;
 export default function styleConstructor(theme = {}) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        containerShadow: {
-            backgroundColor: appStyle.calendarBackground,
-            ...Platform.select({
-                ios: {
-                    shadowColor: '#858F96',
-                    shadowOpacity: 0.25,
-                    shadowRadius: 10,
-                    shadowOffset: { height: 2, width: 0 },
-                    zIndex: 99
-                },
-                android: {
-                    elevation: 3
-                }
-            })
-        },
-        containerWrapper: {
-            paddingBottom: 6
-        },
-        container: {
-            backgroundColor: appStyle.calendarBackground
-        },
-        knobContainer: {
-            position: 'absolute',
-            left: 0,
-            right: 0,
-            height: KNOB_CONTAINER_HEIGHT,
-            bottom: 0,
-            alignItems: 'center',
-            justifyContent: 'center',
-            backgroundColor: appStyle.calendarBackground
-        },
-        knob: {
-            width: 40,
-            height: 4,
-            borderRadius: 3,
-            backgroundColor: appStyle.expandableKnobColor
-        },
-        sectionText: {
-            fontWeight: 'bold',
-            fontSize: 12,
-            lineHeight: 16,
-            color: '#7a92a5',
-            paddingTop: 24,
-            paddingBottom: 8,
-            paddingLeft: 20,
-            paddingRight: 20,
-            backgroundColor: appStyle.calendarBackground,
-            textAlign: 'left',
-            textTransform: 'uppercase'
-        },
-        header: {
-            position: 'absolute',
-            left: 0,
-            right: 0,
-            backgroundColor: appStyle.calendarBackground
-        },
-        headerTitle: {
-            alignSelf: 'center',
-            paddingTop: 13,
-            paddingBottom: 18,
-            fontSize: appStyle.textMonthFontSize,
-            fontFamily: appStyle.textMonthFontFamily,
-            fontWeight: appStyle.textMonthFontWeight,
-            color: appStyle.monthTextColor
-        },
-        weekDayNames: {
-            flexDirection: 'row',
-            justifyContent: 'space-between'
-        },
-        dayHeader: {
-            width: 32,
-            textAlign: 'center',
-            fontSize: appStyle.textDayHeaderFontSize,
-            fontFamily: appStyle.textDayHeaderFontFamily,
-            fontWeight: appStyle.textDayHeaderFontWeight,
-            color: appStyle.textSectionTitleColor
-        },
-        monthView: {
-            backgroundColor: appStyle.calendarBackground
-        },
-        weekContainer: {
-            position: 'absolute',
-            left: 0,
-            right: 0,
-            top: HEADER_HEIGHT + (constants.isAndroid ? 8 : 9), // align row on top of calendar's first row
-        },
-        hidden: {
-            opacity: 0
-        },
-        visible: {
-            opacity: 1
-        },
-        weekCalendar: {
-            marginTop: 12,
-            marginBottom: -2
-        },
-        week: {
-            marginTop: 7,
-            marginBottom: 7,
-            paddingRight: 15,
-            paddingLeft: 15,
-            flexDirection: 'row',
-            justifyContent: 'space-around'
-        },
-        partialWeek: {
-            paddingRight: 0
-        },
-        dayContainer: {
-            flex: 1,
-            alignItems: 'center'
-        },
-        emptyDayContainer: {
-            flex: 1
-        },
-        arrowImage: {
-            tintColor: appStyle.arrowColor,
-            transform: constants.isRTL ? [{ scaleX: -1 }] : undefined
-        },
-        contextWrapper: {
-            flex: 1
-        },
-        todayButtonContainer: {
-            alignItems: appStyle.todayButtonPosition === 'right' ? 'flex-end' : 'flex-start',
-            position: 'absolute',
-            left: 20,
-            right: 20,
-            bottom: 0
-        },
-        todayButton: {
-            height: constants.isTablet ? 40 : 28,
-            paddingHorizontal: constants.isTablet ? 20 : 12,
-            borderRadius: constants.isTablet ? 20 : 14,
-            flexDirection: appStyle.todayButtonPosition === 'right' ? 'row-reverse' : 'row',
-            justifyContent: 'center',
-            alignItems: 'center',
-            backgroundColor: 'white',
-            ...Platform.select({
-                ios: {
-                    shadowColor: '#79838A',
-                    shadowOpacity: 0.3,
-                    shadowRadius: 14,
-                    shadowOffset: { height: 6, width: 0 }
-                },
-                android: {
-                    elevation: 6
-                }
-            })
-        },
-        todayButtonText: {
-            color: appStyle.todayButtonTextColor,
-            fontSize: constants.isTablet ? appStyle.todayButtonFontSize + 2 : appStyle.todayButtonFontSize,
-            fontWeight: appStyle.todayButtonFontWeight,
-            fontFamily: appStyle.todayButtonFontFamily
-        },
-        todayButtonImage: {
-            tintColor: appStyle.todayButtonTextColor,
-            marginLeft: appStyle.todayButtonPosition === 'right' ? 7 : undefined,
-            marginRight: appStyle.todayButtonPosition === 'right' ? undefined : 7
-        },
-        ...(theme?.stylesheet?.expandable?.main || {})
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    containerShadow: {
+      // backgroundColor: appStyle.calendarBackground,
+      backgroundColor: '#303033',
+      ...Platform.select({}),
+    },
+    containerWrapper: {
+      paddingBottom: 6,
+    },
+    container: {
+      backgroundColor: '#303033',
+    },
+    knobContainer: {
+      position: 'absolute',
+      left: 0,
+      right: 0,
+      height: KNOB_CONTAINER_HEIGHT,
+      bottom: 0,
+      alignItems: 'center',
+      justifyContent: 'center',
+      backgroundColor: '#303033',
+    },
+    knob: {
+      width: 40,
+      height: 4,
+      borderRadius: 3,
+      backgroundColor: appStyle.expandableKnobColor,
+    },
+    sectionText: {
+      fontWeight: 'bold',
+      fontSize: 12,
+      lineHeight: 16,
+      color: '#7a92a5',
+      paddingTop: 24,
+      paddingBottom: 8,
+      paddingLeft: 20,
+      paddingRight: 20,
+      backgroundColor: '#303033',
+      textAlign: 'left',
+      textTransform: 'uppercase',
+    },
+    header: {
+      position: 'absolute',
+      left: 0,
+      right: 0,
+      backgroundColor: appStyle.calendarBackground,
+    },
+    headerTitle: {
+      alignSelf: 'center',
+      paddingTop: 13,
+      paddingBottom: 18,
+      fontSize: appStyle.textMonthFontSize,
+      fontFamily: appStyle.textMonthFontFamily,
+      fontWeight: appStyle.textMonthFontWeight,
+      color: appStyle.monthTextColor,
+    },
+    weekDayNames: {
+      flexDirection: 'row',
+      justifyContent: 'space-between',
+    },
+    dayHeader: {
+      width: 32,
+      textAlign: 'center',
+      fontSize: appStyle.textDayHeaderFontSize,
+      fontFamily: appStyle.textDayHeaderFontFamily,
+      fontWeight: appStyle.textDayHeaderFontWeight,
+      color: '#fff',
+    },
+    monthView: {
+      backgroundColor: appStyle.calendarBackground,
+    },
+    weekContainer: {
+      position: 'absolute',
+      left: 0,
+      right: 0,
+      top: HEADER_HEIGHT + (constants.isAndroid ? 8 : 9), // align row on top of calendar's first row
+    },
+    hidden: {
+      opacity: 0,
+    },
+    visible: {
+      opacity: 1,
+    },
+    weekCalendar: {
+      marginTop: 7,
+      marginBottom: -2,
+    },
+    week: {
+      marginTop: 7,
+      marginBottom: 7,
+      paddingRight: 15,
+      paddingLeft: 15,
+      flexDirection: 'row',
+      justifyContent: 'space-around',
+    },
+    partialWeek: {
+      paddingRight: 0,
+    },
+    dayContainer: {
+      flex: 1,
+      alignItems: 'center',
+    },
+    emptyDayContainer: {
+      flex: 1,
+    },
+    arrowImage: {
+      tintColor: appStyle.arrowColor,
+      transform: constants.isRTL ? [{ scaleX: -1 }] : undefined,
+    },
+    contextWrapper: {
+      flex: 1,
+    },
+    todayButtonContainer: {
+      alignItems: appStyle.todayButtonPosition === 'right' ? 'flex-end' : 'flex-start',
+      position: 'absolute',
+      left: 20,
+      right: 20,
+      bottom: 0,
+    },
+    todayButton: {
+      height: constants.isTablet ? 40 : 28,
+      paddingHorizontal: constants.isTablet ? 20 : 12,
+      borderRadius: constants.isTablet ? 20 : 14,
+      flexDirection: appStyle.todayButtonPosition === 'right' ? 'row-reverse' : 'row',
+      justifyContent: 'center',
+      alignItems: 'center',
+      backgroundColor: 'white',
+      ...Platform.select({
+        ios: {
+          shadowColor: '#79838A',
+          shadowOpacity: 0.3,
+          shadowRadius: 14,
+          shadowOffset: { height: 6, width: 0 },
+        },
+        android: {
+          elevation: 6,
+        },
+      }),
+    },
+    todayButtonText: {
+      color: appStyle.todayButtonTextColor,
+      fontSize: constants.isTablet ? appStyle.todayButtonFontSize + 2 : appStyle.todayButtonFontSize,
+      fontWeight: appStyle.todayButtonFontWeight,
+      fontFamily: appStyle.todayButtonFontFamily,
+    },
+    todayButtonImage: {
+      tintColor: appStyle.todayButtonTextColor,
+      marginLeft: appStyle.todayButtonPosition === 'right' ? 7 : undefined,
+      marginRight: appStyle.todayButtonPosition === 'right' ? undefined : 7,
+    },
+    ...(theme?.stylesheet?.expandable?.main || {}),
+  });
 }
diff --git a/node_modules/react-native-calendars/src/expandableCalendar/week.js b/node_modules/react-native-calendars/src/expandableCalendar/week.js
index 2d37a0e..f73fefe 100644
--- a/node_modules/react-native-calendars/src/expandableCalendar/week.js
+++ b/node_modules/react-native-calendars/src/expandableCalendar/week.js
@@ -1,65 +1,99 @@
-import XDate from 'xdate';
-import React, { useRef, useMemo, useCallback } from 'react';
+import React, { useCallback, useMemo, useRef } from 'react';
 import { View } from 'react-native';
+
 import isEqual from 'lodash/isEqual';
-import { getPartialWeekDates, getWeekDates, sameMonth } from '../dateutils';
-import { parseDate, toMarkingFormat } from '../interface';
-import { getState } from '../day-state-manager';
-import { extractDayProps } from '../componentUpdater';
+import XDate from 'xdate';
+
 import styleConstructor from './style';
+
 import Day from '../calendar/day/index';
+import { extractDayProps } from '../componentUpdater';
+import { getPartialWeekDates, getWeekDates, sameMonth } from '../dateutils';
+import { getState } from '../day-state-manager';
+import { parseDate, toMarkingFormat } from '../interface';
+
 function arePropsEqual(prevProps, nextProps) {
-    const { context: prevContext, markedDates: prevMarkings, ...prevOthers } = prevProps;
-    const { context: nextContext, markedDates: nextMarkings, ...nextOthers } = nextProps;
-    return isEqual(prevContext, nextContext) && isEqual(prevMarkings, nextMarkings) && isEqual(prevOthers, nextOthers);
+  const { context: prevContext, markedDates: prevMarkings, ...prevOthers } = prevProps;
+  const { context: nextContext, markedDates: nextMarkings, ...nextOthers } = nextProps;
+  return isEqual(prevContext, nextContext) && isEqual(prevMarkings, nextMarkings) && isEqual(prevOthers, nextOthers);
 }
 const Week = React.memo((props) => {
-    const { theme, current, firstDay, hideExtraDays, markedDates, onDayPress, onDayLongPress, style: propsStyle, numberOfDays = 1, timelineLeftInset, testID, } = props;
-    const style = useRef(styleConstructor(theme));
-    const disableDaySelection = useMemo(() => {
-        return !!numberOfDays && numberOfDays > 1;
-    }, [numberOfDays]);
-    const getWeek = useCallback((date) => {
-        if (date) {
-            return getWeekDates(date, firstDay);
-        }
-    }, [firstDay]);
-    const partialWeekStyle = useMemo(() => {
-        return [style.current.partialWeek, { paddingLeft: timelineLeftInset }];
-    }, [timelineLeftInset]);
-    const dayProps = extractDayProps(props);
-    const currXdate = useMemo(() => parseDate(current), [current]);
-    const renderDay = (day, id) => {
-        // hide extra days
-        if (current && hideExtraDays) {
-            if (!sameMonth(day, currXdate)) {
-                return <View key={id} style={style.current.emptyDayContainer}/>;
-            }
-        }
-        const dayString = toMarkingFormat(day);
-        return (<View style={style.current.dayContainer} key={id}>
-        <Day {...dayProps} testID={`${testID}.day_${dayString}`} date={dayString} state={getState(day, currXdate, props, disableDaySelection)} marking={disableDaySelection ? { ...markedDates?.[dayString], disableTouchEvent: true } : markedDates?.[dayString]} onPress={onDayPress} onLongPress={onDayLongPress}/>
-      </View>);
-    };
-    const renderWeek = () => {
-        const dates = numberOfDays > 1 ? getPartialWeekDates(current, numberOfDays) : getWeek(current);
-        const week = [];
-        if (dates) {
-            const todayIndex = dates?.indexOf(parseDate(new Date())) || -1;
-            const sliced = dates.slice(todayIndex, numberOfDays);
-            const datesToRender = numberOfDays > 1 && todayIndex > -1 ? sliced : dates;
-            datesToRender.forEach((day, id) => {
-                const d = day instanceof XDate ? day : new XDate(day);
-                week.push(renderDay(d, id));
-            }, this);
-        }
-        return week;
-    };
-    return (<View style={style.current.container} testID={`${testID}.week_${current}`}>
+  const {
+    theme,
+    current,
+    firstDay,
+    hideExtraDays,
+    markedDates,
+    onDayPress,
+    onDayLongPress,
+    style: propsStyle,
+    numberOfDays = 1,
+    timelineLeftInset,
+    testID,
+  } = props;
+  const style = useRef(styleConstructor(theme));
+
+  const disableDaySelection = useMemo(() => {
+    return !!numberOfDays && numberOfDays > 1;
+  }, [numberOfDays]);
+  const getWeek = useCallback(
+    (date) => {
+      if (date) {
+        return getWeekDates(date, firstDay);
+      }
+    },
+    [firstDay],
+  );
+  const partialWeekStyle = useMemo(() => {
+    return [style.current.partialWeek, { paddingLeft: timelineLeftInset }];
+  }, [timelineLeftInset]);
+  const dayProps = extractDayProps(props);
+  const currXdate = useMemo(() => parseDate(current), [current]);
+  const renderDay = (day, id) => {
+    // hide extra days
+    if (current && hideExtraDays) {
+      if (!sameMonth(day, currXdate)) {
+        return <View key={id} style={style.current.emptyDayContainer} />;
+      }
+    }
+    const dayString = toMarkingFormat(day);
+    return (
+      <View style={style.current.dayContainer} key={id}>
+        <Day
+          {...dayProps}
+          testID={`${testID}.day_${dayString}`}
+          date={dayString}
+          state={getState(day, currXdate, props, disableDaySelection)}
+          marking={
+            disableDaySelection ? { ...markedDates?.[dayString], disableTouchEvent: true } : markedDates?.[dayString]
+          }
+          onPress={onDayPress}
+          onLongPress={onDayLongPress}
+        />
+      </View>
+    );
+  };
+  const renderWeek = () => {
+    const dates = numberOfDays > 1 ? getPartialWeekDates(current, numberOfDays) : getWeek(current);
+    const week = [];
+    if (dates) {
+      const todayIndex = dates?.indexOf(parseDate(new Date())) || -1;
+      const sliced = dates.slice(todayIndex, numberOfDays);
+      const datesToRender = numberOfDays > 1 && todayIndex > -1 ? sliced : dates;
+      datesToRender.forEach((day, id) => {
+        const d = day instanceof XDate ? day : new XDate(day);
+        week.push(renderDay(d, id));
+      }, this);
+    }
+    return week;
+  };
+  return (
+    <View style={[style.current.container]} testID={`${testID}.week_${current}`}>
       <View style={[style.current.week, numberOfDays > 1 ? partialWeekStyle : undefined, propsStyle]}>
         {renderWeek()}
       </View>
-    </View>);
+    </View>
+  );
 }, arePropsEqual);
 export default Week;
 Week.displayName = 'Week';
diff --git a/node_modules/react-native-calendars/src/style.js b/node_modules/react-native-calendars/src/style.js
index 5efb8bd..aed2efa 100644
--- a/node_modules/react-native-calendars/src/style.js
+++ b/node_modules/react-native-calendars/src/style.js
@@ -1,10 +1,10 @@
 // default values for app style (see all options for theme type in types.ts)
 const FOREGROUND_COLOR = 'white';
-const DEFAULT_TEXT_COLOR = '#2d4150';
-const SECONDARY_TEXT_COLOR = '#00BBF2';
+const DEFAULT_TEXT_COLOR = '#fff';
+const SECONDARY_TEXT_COLOR = '#BFFF41';
 const AGENDA_TEXT_COLOR = '#7a92a5';
 const AGENDA_BG_COLOR = '#f2F4f5';
-const DISABLED_COLOR = '#d9e1e8';
+const DISABLED_COLOR = '#8E8E93';
 export const textDayFontFamily = 'System';
 export const textMonthFontFamily = 'System';
 export const textDayHeaderFontFamily = 'System';
@@ -23,8 +23,8 @@ export const arrowStyle = undefined;
 export const calendarBackground = FOREGROUND_COLOR;
 export const textSectionTitleColor = '#b6c1cd';
 export const textSectionTitleDisabledColor = DISABLED_COLOR;
-export const selectedDayBackgroundColor = SECONDARY_TEXT_COLOR;
-export const selectedDayTextColor = FOREGROUND_COLOR;
+export const selectedDayBackgroundColor = '#fff';
+export const selectedDayTextColor = '#000000';
 export const todayBackgroundColor = undefined;
 export const todayTextColor = SECONDARY_TEXT_COLOR;
 export const dayTextColor = DEFAULT_TEXT_COLOR;
@@ -46,6 +46,6 @@ export const agendaKnobColor = AGENDA_BG_COLOR;
 export const expandableKnobColor = '#e8ecf0';
 export const backgroundColor = AGENDA_BG_COLOR; // Agenda's reservations bg color - renamed: 'reservationsBackgroundColor'. TODO: remove in V2
 export const reservationsBackgroundColor = AGENDA_BG_COLOR;
-export const todayButtonTextColor = SECONDARY_TEXT_COLOR;
+export const todayButtonTextColor = '#000000';
 export const todayButtonPosition = undefined; // right' / 'left'(default)
 export const weekVerticalMargin = 7;
diff --git a/node_modules/react-native-calendars/src/timeline-list/index.js b/node_modules/react-native-calendars/src/timeline-list/index.js
index 372370c..38940d8 100644
--- a/node_modules/react-native-calendars/src/timeline-list/index.js
+++ b/node_modules/react-native-calendars/src/timeline-list/index.js
@@ -1,93 +1,144 @@
-import throttle from 'lodash/throttle';
-import flatten from 'lodash/flatten';
-import dropRight from 'lodash/dropRight';
 import React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
-import { isToday, generateDay } from '../dateutils';
-import InfiniteList from '../infinite-list';
+
+import dropRight from 'lodash/dropRight';
+import flatten from 'lodash/flatten';
+import throttle from 'lodash/throttle';
+
+import useTimelinePages, { INITIAL_PAGE, NEAR_EDGE_THRESHOLD, PAGES_COUNT } from './useTimelinePages';
+
+import constants from '../commons/constants';
+import { generateDay, isToday } from '../dateutils';
 import Context from '../expandableCalendar/Context';
 import { UpdateSources } from '../expandableCalendar/commons';
+import InfiniteList from '../infinite-list';
 import Timeline from '../timeline/Timeline';
-import useTimelinePages, { INITIAL_PAGE, NEAR_EDGE_THRESHOLD, PAGES_COUNT } from './useTimelinePages';
-import constants from '../commons/constants';
+
 const TimelineList = (props) => {
-    const { timelineProps, events, renderItem, showNowIndicator, scrollToFirst, scrollToNow, initialTime } = props;
-    const { date, updateSource, setDate, numberOfDays = 1, timelineLeftInset } = useContext(Context);
-    const listRef = useRef();
-    const prevDate = useRef(date);
-    const [timelineOffset, setTimelineOffset] = useState();
-    const { pages, pagesRef, resetPages, resetPagesDebounce, scrollToPageDebounce, shouldResetPages, isOutOfRange } = useTimelinePages({ date, listRef, numberOfDays });
-    const scrollToCurrentDate = useCallback((date) => {
-        const datePageIndex = pagesRef.current.indexOf(date);
-        if (updateSource !== UpdateSources.LIST_DRAG) {
-            if (isOutOfRange(datePageIndex)) {
-                updateSource === UpdateSources.DAY_PRESS ? resetPages(date) : resetPagesDebounce(date);
-            }
-            else {
-                scrollToPageDebounce(datePageIndex);
-            }
-        }
-        prevDate.current = date;
-    }, [updateSource]);
-    const initialOffset = useMemo(() => constants.isAndroidRTL ? constants.screenWidth * (PAGES_COUNT - INITIAL_PAGE - 1) : constants.screenWidth * INITIAL_PAGE, []);
-    useEffect(() => {
-        if (date !== prevDate.current) {
-            scrollToCurrentDate(date);
-        }
-    }, [date]);
-    const onScroll = useCallback(() => {
-        if (shouldResetPages.current) {
-            resetPagesDebounce.cancel();
-        }
-    }, []);
-    const onMomentumScrollEnd = useCallback(() => {
-        if (shouldResetPages.current) {
-            resetPagesDebounce(prevDate.current);
-        }
-    }, []);
-    const onPageChange = useCallback(throttle((pageIndex) => {
-        const newDate = pages[constants.isAndroidRTL ? pageIndex - 1 : pageIndex];
-        if (newDate !== prevDate.current) {
-            setDate(newDate, UpdateSources.LIST_DRAG);
-        }
-    }, 0), [pages]);
-    const onReachNearEdge = useCallback(() => {
-        shouldResetPages.current = true;
-    }, []);
-    const onTimelineOffsetChange = useCallback(offset => {
-        setTimelineOffset(offset);
-    }, []);
-    const renderPage = useCallback((_type, item, index) => {
-        const isCurrent = prevDate.current === item;
-        const isInitialPage = index === INITIAL_PAGE;
-        const _isToday = isToday(item);
-        const weekEvents = [events[item] || [], events[generateDay(item, 1)] || [], events[generateDay(item, 2)] || [], events[generateDay(item, 3)] || [], events[generateDay(item, 4)] || [], events[generateDay(item, 5)] || [], events[generateDay(item, 6)] || []];
-        const weekDates = [item, generateDay(item, 1), generateDay(item, 2), generateDay(item, 3), generateDay(item, 4), generateDay(item, 5), generateDay(item, 6)];
-        const numberOfDaysToDrop = (7 - numberOfDays);
-        const _timelineProps = {
-            ...timelineProps,
-            key: item,
-            date: dropRight(weekDates, numberOfDaysToDrop),
-            events: flatten(dropRight(weekEvents, numberOfDaysToDrop)),
-            scrollToNow: _isToday && isInitialPage && scrollToNow,
-            initialTime: !_isToday && isInitialPage ? initialTime : undefined,
-            scrollToFirst: !_isToday && isInitialPage && scrollToFirst,
-            scrollOffset: timelineOffset,
-            onChangeOffset: onTimelineOffsetChange,
-            showNowIndicator: _isToday && showNowIndicator,
-            numberOfDays,
-            timelineLeftInset
-        };
-        if (renderItem) {
-            return renderItem(_timelineProps, { item, index, isCurrent, isInitialPage, isToday: _isToday });
+  const { timelineProps, events, renderItem, showNowIndicator, scrollToFirst, scrollToNow, initialTime } = props;
+  const { date, updateSource, setDate, numberOfDays = 1, timelineLeftInset } = useContext(Context);
+  const listRef = useRef();
+  const prevDate = useRef(date);
+  const [timelineOffset, setTimelineOffset] = useState();
+  const { pages, pagesRef, resetPages, resetPagesDebounce, scrollToPageDebounce, shouldResetPages, isOutOfRange } =
+    useTimelinePages({ date, listRef, numberOfDays });
+  const scrollToCurrentDate = useCallback(
+    (date) => {
+      const datePageIndex = pagesRef.current.indexOf(date);
+      if (updateSource !== UpdateSources.LIST_DRAG) {
+        if (isOutOfRange(datePageIndex)) {
+          updateSource === UpdateSources.DAY_PRESS ? resetPages(date) : resetPagesDebounce(date);
+        } else {
+          scrollToPageDebounce(datePageIndex);
         }
-        return (<>
-          <Timeline {..._timelineProps}/>
+      }
+      prevDate.current = date;
+    },
+    [updateSource],
+  );
+  const initialOffset = useMemo(
+    () =>
+      constants.isAndroidRTL
+        ? constants.screenWidth * (PAGES_COUNT - INITIAL_PAGE - 1)
+        : constants.screenWidth * INITIAL_PAGE,
+    [],
+  );
+  useEffect(() => {
+    if (date !== prevDate.current) {
+      scrollToCurrentDate(date);
+    }
+  }, [date]);
+  const onScroll = useCallback(() => {
+    if (shouldResetPages.current) {
+      resetPagesDebounce.cancel();
+    }
+  }, []);
+  const onMomentumScrollEnd = useCallback(() => {
+    if (shouldResetPages.current) {
+      resetPagesDebounce(prevDate.current);
+    }
+  }, []);
+  const onPageChange = useCallback(
+    throttle((pageIndex) => {
+      const newDate = pages[constants.isAndroidRTL ? pageIndex - 1 : pageIndex];
+      if (newDate !== prevDate.current) {
+        setDate(newDate, UpdateSources.LIST_DRAG);
+      }
+    }, 0),
+    [pages],
+  );
+  const onReachNearEdge = useCallback(() => {
+    shouldResetPages.current = true;
+  }, []);
+  const onTimelineOffsetChange = useCallback((offset) => {
+    setTimelineOffset(offset);
+  }, []);
+  const renderPage = useCallback(
+    (_type, item, index) => {
+      const isCurrent = prevDate.current === item;
+      const isInitialPage = index === INITIAL_PAGE;
+      const _isToday = isToday(item);
+      const weekEvents = [
+        events[item] || [],
+        events[generateDay(item, 1)] || [],
+        events[generateDay(item, 2)] || [],
+        events[generateDay(item, 3)] || [],
+        events[generateDay(item, 4)] || [],
+        events[generateDay(item, 5)] || [],
+        events[generateDay(item, 6)] || [],
+      ];
+      const weekDates = [
+        item,
+        generateDay(item, 1),
+        generateDay(item, 2),
+        generateDay(item, 3),
+        generateDay(item, 4),
+        generateDay(item, 5),
+        generateDay(item, 6),
+      ];
+      const numberOfDaysToDrop = 7 - numberOfDays;
+      const _timelineProps = {
+        ...timelineProps,
+        key: item,
+        date: dropRight(weekDates, numberOfDaysToDrop),
+        events: flatten(dropRight(weekEvents, numberOfDaysToDrop)),
+        scrollToNow: _isToday && isInitialPage && scrollToNow,
+        initialTime: !_isToday && isInitialPage ? initialTime : undefined,
+        scrollToFirst: !_isToday && isInitialPage && scrollToFirst,
+        scrollOffset: timelineOffset,
+        onChangeOffset: onTimelineOffsetChange,
+        showNowIndicator: _isToday && showNowIndicator,
+        numberOfDays,
+        timelineLeftInset,
+      };
+      if (renderItem) {
+        return renderItem(_timelineProps, { item, index, isCurrent, isInitialPage, isToday: _isToday });
+      }
+      return (
+        <>
+          <Timeline {..._timelineProps} />
           {/* NOTE: Keeping this for easy debugging */}
           {/* <Text style={{position: 'absolute'}}>{item}</Text>*/}
-        </>);
-    }, [events, timelineOffset, showNowIndicator, numberOfDays]);
-    return (<InfiniteList isHorizontal ref={listRef} data={pages} renderItem={renderPage} onPageChange={onPageChange} onReachNearEdge={onReachNearEdge} onReachNearEdgeThreshold={NEAR_EDGE_THRESHOLD} onScroll={onScroll} extendedState={{ todayEvents: events[date], pages }} initialOffset={initialOffset} scrollViewProps={{
-            onMomentumScrollEnd
-        }}/>);
+        </>
+      );
+    },
+    [events, timelineOffset, showNowIndicator, numberOfDays],
+  );
+  return (
+    <InfiniteList
+      isHorizontal
+      ref={listRef}
+      data={pages}
+      renderItem={renderPage}
+      onPageChange={onPageChange}
+      onReachNearEdge={onReachNearEdge}
+      onReachNearEdgeThreshold={NEAR_EDGE_THRESHOLD}
+      onScroll={onScroll}
+      extendedState={{ todayEvents: events[date], pages }}
+      initialOffset={initialOffset}
+      scrollViewProps={{
+        onMomentumScrollEnd,
+      }}
+    />
+  );
 };
 export default TimelineList;
diff --git a/node_modules/react-native-calendars/src/timeline/EventBlock.js b/node_modules/react-native-calendars/src/timeline/EventBlock.js
index fbe5f19..0f6cc37 100644
--- a/node_modules/react-native-calendars/src/timeline/EventBlock.js
+++ b/node_modules/react-native-calendars/src/timeline/EventBlock.js
@@ -1,38 +1,50 @@
-import XDate from 'xdate';
 import React, { useCallback, useMemo } from 'react';
-import { View, Text, TouchableOpacity } from 'react-native';
+import { Text, TouchableOpacity, View } from 'react-native';
+
+import XDate from 'xdate';
+
 const TEXT_LINE_HEIGHT = 17;
 const EVENT_DEFAULT_COLOR = '#add8e6';
 const EventBlock = (props) => {
-    const { index, event, renderEvent, onPress, format24h, styles } = props;
-    // Fixing the number of lines for the event title makes this calculation easier.
-    // However it would make sense to overflow the title to a new line if needed
-    const numberOfLines = Math.floor(event.height / TEXT_LINE_HEIGHT);
-    const formatTime = format24h ? 'HH:mm' : 'hh:mm A';
-    const eventStyle = useMemo(() => {
-        return {
-            left: event.left,
-            height: event.height,
-            width: event.width,
-            top: event.top,
-            backgroundColor: event.color ? event.color : EVENT_DEFAULT_COLOR
-        };
-    }, [event]);
-    const _onPress = useCallback(() => {
-        onPress(index);
-    }, [index, onPress]);
-    return (<TouchableOpacity testID={props.testID} activeOpacity={0.9} onPress={_onPress} style={[styles.event, eventStyle]}>
-      {renderEvent ? (renderEvent(event)) : (<View>
+  const { index, event, renderEvent, onPress, format24h, styles } = props;
+  // Fixing the number of lines for the event title makes this calculation easier.
+  // However it would make sense to overflow the title to a new line if needed
+  const numberOfLines = Math.floor(event.height / TEXT_LINE_HEIGHT);
+  const formatTime = format24h ? 'HH:mm' : 'hh:mm A';
+  const eventStyle = useMemo(() => {
+    return {
+      left: event.left,
+      height: event.height,
+      width: event.width,
+      top: event.top,
+      backgroundColor: event.color ? event.color : EVENT_DEFAULT_COLOR,
+    };
+  }, [event]);
+  const _onPress = useCallback(() => {
+    onPress(index);
+  }, [index, onPress]);
+  return (
+    <TouchableOpacity testID={props.testID} activeOpacity={0.9} onPress={_onPress} style={[styles.event, eventStyle]}>
+      {renderEvent ? (
+        renderEvent(event)
+      ) : (
+        <View>
           <Text numberOfLines={1} style={styles.eventTitle}>
             {event.title || 'Event'}
           </Text>
-          {numberOfLines > 1 ? (<Text numberOfLines={numberOfLines - 1} style={[styles.eventSummary]}>
+          {numberOfLines > 1 ? (
+            <Text numberOfLines={numberOfLines - 1} style={[styles.eventSummary]}>
               {event.summary || ' '}
-            </Text>) : null}
-          {numberOfLines > 2 ? (<Text style={styles.eventTimes} numberOfLines={1}>
+            </Text>
+          ) : null}
+          {numberOfLines > 2 ? (
+            <Text style={styles.eventTimes} numberOfLines={1}>
               {new XDate(event.start).toString(formatTime)} - {new XDate(event.end).toString(formatTime)}
-            </Text>) : null}
-        </View>)}
-    </TouchableOpacity>);
+            </Text>
+          ) : null}
+        </View>
+      )}
+    </TouchableOpacity>
+  );
 };
 export default EventBlock;
diff --git a/node_modules/react-native-calendars/src/timeline/NowIndicator.js b/node_modules/react-native-calendars/src/timeline/NowIndicator.js
index 9d82188..9ad40d4 100644
--- a/node_modules/react-native-calendars/src/timeline/NowIndicator.js
+++ b/node_modules/react-native-calendars/src/timeline/NowIndicator.js
@@ -1,16 +1,20 @@
 import React, { useMemo } from 'react';
 import { View } from 'react-native';
-import { calcTimeOffset } from './helpers/presenter';
+
 import { HOUR_BLOCK_HEIGHT } from './Packer';
+import { calcTimeOffset } from './helpers/presenter';
+
 const NowIndicator = (props) => {
-    const { styles, width, left } = props;
-    const indicatorPosition = calcTimeOffset(HOUR_BLOCK_HEIGHT);
-    const nowIndicatorStyle = useMemo(() => {
-        return [styles.nowIndicator, { top: indicatorPosition, left }];
-    }, [indicatorPosition, left]);
-    return (<View style={nowIndicatorStyle}>
-      <View style={[styles.nowIndicatorLine, { width }]}/>
-      <View style={styles.nowIndicatorKnob}/>
-    </View>);
+  const { styles, width, left } = props;
+  const indicatorPosition = calcTimeOffset(HOUR_BLOCK_HEIGHT);
+  const nowIndicatorStyle = useMemo(() => {
+    return [styles.nowIndicator, { top: indicatorPosition, left }];
+  }, [indicatorPosition, left]);
+  return (
+    <View style={nowIndicatorStyle}>
+      <View style={[styles.nowIndicatorLine, { width }]} />
+      <View style={styles.nowIndicatorKnob} />
+    </View>
+  );
 };
 export default NowIndicator;
diff --git a/node_modules/react-native-calendars/src/timeline/helpers/presenter.js b/node_modules/react-native-calendars/src/timeline/helpers/presenter.js
index 6a50437..6aefa9e 100644
--- a/node_modules/react-native-calendars/src/timeline/helpers/presenter.js
+++ b/node_modules/react-native-calendars/src/timeline/helpers/presenter.js
@@ -1,25 +1,29 @@
 import XDate from 'xdate';
+
 import constants from '../../commons/constants';
 import { generateDay } from '../../dateutils';
+
 export function calcTimeByPosition(yPosition, hourBlockHeight) {
-    let time = yPosition / hourBlockHeight;
-    time = Math.floor(time * 2) / 2;
-    const hour = Math.floor(time);
-    const minutes = (time - Math.floor(time)) * 60;
-    return { hour, minutes };
+  let time = yPosition / hourBlockHeight;
+  time = Math.floor(time * 2) / 2;
+  const hour = Math.floor(time);
+  const minutes = (time - Math.floor(time)) * 60;
+  return { hour, minutes };
 }
 export function calcDateByPosition(xPosition, timelineLeftInset, numberOfDays = 1, firstDate = new XDate()) {
-    const timelineWidth = constants.screenWidth - timelineLeftInset;
-    const dayWidth = timelineWidth / numberOfDays;
-    const positionIndex = Math.floor((xPosition - timelineLeftInset) / dayWidth);
-    return generateDay(firstDate, positionIndex);
+  const timelineWidth = constants.screenWidth - timelineLeftInset;
+  const dayWidth = timelineWidth / numberOfDays;
+  const positionIndex = Math.floor((xPosition - timelineLeftInset) / dayWidth);
+  return generateDay(firstDate, positionIndex);
 }
 export function buildTimeString(hour = 0, minutes = 0, date = '') {
-    return `${date} ${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00`.trimStart();
+  return `${date} ${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00`.trimStart();
 }
 export function calcTimeOffset(hourBlockHeight, hour, minutes) {
-    const now = new Date();
-    const h = hour ?? now.getHours();
-    const m = minutes ?? now.getMinutes();
-    return (h + m / 60) * hourBlockHeight;
+  const now = new Date();
+  console.log({ now });
+  const h = hour ?? now.getHours();
+  const m = minutes ?? now.getMinutes();
+
+  return (h + m / 60) * hourBlockHeight - 600; // 600 mean that range is from 6:00
 }
diff --git a/node_modules/react-native-calendars/src/timeline/style.js b/node_modules/react-native-calendars/src/timeline/style.js
index 18593af..119230d 100644
--- a/node_modules/react-native-calendars/src/timeline/style.js
+++ b/node_modules/react-native-calendars/src/timeline/style.js
@@ -1,112 +1,121 @@
 import { StyleSheet } from 'react-native';
-import * as defaultStyle from '../style';
+
 import constants from '../commons/constants';
-const LINE_COLOR = '#D8D8D8';
-const TIME_LABEL_COLOR = '#AAAAAA';
-const EVENT_TEXT_COLOR = '#615B73';
-const NOW_INDICATOR_COLOR = 'red';
-const UNAVAILABLE_HOURS_BLOCK_COLOR = '#F8F9FA';
+import * as defaultStyle from '../style';
+
+const LINE_COLOR = '#C7C7CC';
+const TIME_LABEL_COLOR = '#8E8E93';
+const EVENT_TEXT_COLOR = '#000000';
+const NOW_INDICATOR_COLOR = '#BFFF41';
+const UNAVAILABLE_HOURS_BLOCK_COLOR = '#181A1E';
 export default function styleConstructor(theme = {}, calendarHeight) {
-    const appStyle = { ...defaultStyle, ...theme };
-    return StyleSheet.create({
-        container: {
-            backgroundColor: appStyle.calendarBackground,
-            ...appStyle.timelineContainer,
-        },
-        contentStyle: {
-            backgroundColor: appStyle.calendarBackground,
-            ...appStyle.contentStyle,
-            flexDirection: 'row',
-            height: calendarHeight + 10
-        },
-        line: {
-            height: 1,
-            backgroundColor: LINE_COLOR,
-            ...theme.line,
-            position: 'absolute'
-        },
-        verticalLine: {
-            width: 1,
-            backgroundColor: LINE_COLOR,
-            ...appStyle.verticalLine,
-            position: 'absolute',
-            height: '105%'
-        },
-        nowIndicator: {
-            position: 'absolute',
-            right: 0
-        },
-        nowIndicatorLine: {
-            height: 1,
-            backgroundColor: NOW_INDICATOR_COLOR,
-            ...appStyle.nowIndicatorLine,
-            position: 'absolute',
-            left: 0,
-            right: 0
-        },
-        nowIndicatorKnob: {
-            width: 7,
-            height: 7,
-            borderRadius: 4,
-            backgroundColor: NOW_INDICATOR_COLOR,
-            ...appStyle.nowIndicatorKnob,
-            position: 'absolute',
-            left: -3,
-            top: -3
-        },
-        timeLabel: {
-            color: TIME_LABEL_COLOR,
-            fontSize: 10,
-            fontWeight: '500',
-            fontFamily: constants.isIOS ? 'Helvetica Neue' : 'Roboto',
-            paddingLeft: 12,
-            textAlign: 'center',
-            ...appStyle.timeLabel,
-            position: 'absolute'
-        },
-        unavailableHoursBlock: {
-            position: 'absolute',
-            right: 0,
-            backgroundColor: UNAVAILABLE_HOURS_BLOCK_COLOR
-        },
-        event: {
-            opacity: 1,
-            paddingLeft: 4,
-            paddingTop: 5,
-            paddingBottom: 0,
-            backgroundColor: '#F0F4FF',
-            borderColor: '#DDE5FD',
-            borderWidth: 1,
-            ...appStyle.event,
-            position: 'absolute',
-            flex: 1,
-            flexDirection: 'column',
-            alignItems: 'flex-start',
-            overflow: 'hidden',
-            minHeight: 25,
-        },
-        eventTitle: {
-            color: EVENT_TEXT_COLOR,
-            fontWeight: '600',
-            ...appStyle.eventTitle,
-            minHeight: 15
-        },
-        eventSummary: {
-            color: EVENT_TEXT_COLOR,
-            fontSize: 12,
-            ...appStyle.eventSummary,
-            flexWrap: 'wrap'
-        },
-        eventTimes: {
-            marginTop: 3,
-            color: EVENT_TEXT_COLOR,
-            fontSize: 10,
-            fontWeight: 'bold',
-            ...appStyle.eventTimes,
-            flexWrap: 'wrap'
-        },
-        eventsContainer: {
-            flex: 1
-        }
-    });
+  const appStyle = { ...defaultStyle, ...theme };
+  return StyleSheet.create({
+    container: {
+      //   backgroundColor: appStyle.calendarBackground,
+      backgroundColor: '#181A1E',
+      ...appStyle.timelineContainer,
+    },
+    contentStyle: {
+      //   backgroundColor: appStyle.calendarBackground,
+      backgroundColor: '#181A1E',
+      ...appStyle.contentStyle,
+      flexDirection: 'row',
+      height: calendarHeight + 10,
+    },
+    line: {
+      height: 1,
+      backgroundColor: LINE_COLOR,
+      ...theme.line,
+      position: 'absolute',
+    },
+    verticalLine: {
+      width: 1,
+      backgroundColor: LINE_COLOR,
+      ...appStyle.verticalLine,
+      position: 'absolute',
+      height: '105%',
+    },
+    nowIndicator: {
+      position: 'absolute',
+      right: 0,
+    },
+    nowIndicatorLine: {
+      height: 1,
+      backgroundColor: NOW_INDICATOR_COLOR,
+      ...appStyle.nowIndicatorLine,
+      position: 'absolute',
+      left: 0,
+      right: 0,
+    },
+    nowIndicatorKnob: {
+      width: 7,
+      height: 7,
+      borderRadius: 4,
+      backgroundColor: NOW_INDICATOR_COLOR,
+      ...appStyle.nowIndicatorKnob,
+      position: 'absolute',
+      left: -3,
+      top: -3,
+    },
+    timeLabel: {
+      color: TIME_LABEL_COLOR,
+      fontSize: 10,
+      fontWeight: '500',
+      fontFamily: constants.isIOS ? 'Helvetica Neue' : 'Roboto',
+      paddingLeft: 12,
+      textAlign: 'center',
+      ...appStyle.timeLabel,
+      position: 'absolute',
+    },
+    unavailableHoursBlock: {
+      position: 'absolute',
+      right: 0,
+      backgroundColor: UNAVAILABLE_HOURS_BLOCK_COLOR,
+    },
+    event: {
+      opacity: 1,
+      paddingLeft: 4,
+      paddingTop: 5,
+      paddingBottom: 0,
+      backgroundColor: '#F0F4FF',
+      borderColor: '#DDE5FD',
+      borderWidth: 1,
+      ...appStyle.event,
+      position: 'absolute',
+      flex: 1,
+      flexDirection: 'column',
+      alignItems: 'flex-start',
+      overflow: 'hidden',
+      minHeight: 25,
+      borderLeftWidth: 3,
+      borderLeftColor: '#BFFF41',
+      borderRadius: 5,
+    },
+    eventTitle: {
+      color: EVENT_TEXT_COLOR,
+      fontWeight: '400',
+      minHeight: 15,
+      fontSize: 13,
+      ...appStyle.eventTitle,
+    },
+    eventSummary: {
+      color: EVENT_TEXT_COLOR,
+      fontWeight: '600',
+      fontSize: 13,
+      ...appStyle.eventSummary,
+      flexWrap: 'wrap',
+    },
+    eventTimes: {
+      marginTop: 3,
+      color: EVENT_TEXT_COLOR,
+      fontSize: 10,
+      fontWeight: 'bold',
+      ...appStyle.eventTimes,
+      flexWrap: 'wrap',
+    },
+    eventsContainer: {
+      flex: 1,
+    },
+  });
 }
