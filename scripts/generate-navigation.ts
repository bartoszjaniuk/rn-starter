import { A, D, F, G, O, S, pipe } from '@mobily/ts-belt';

import * as fs from 'fs';
import { glob } from 'glob';
import j, { ASTNode, Identifier, JSXAttribute, JSXElement, ObjectExpression, SpreadElement } from 'jscodeshift';
import * as path from 'path';
import * as prettier from 'prettier';
import YAML from 'yamljs';

type Writeable<T> = {
  -readonly [P in keyof T]: T[P];
};

type ScreenObject = Record<
  string,
  {
    readonly props?: {
      readonly options?: Record<string, unknown>;
      readonly name?: string;
    };
    readonly path?: string;
    readonly params?: Record<string, unknown>;
    readonly lazy?: boolean;
  }
>;

type Screen = string | ScreenObject;

type ScreenParams = {
  spreadElement: SpreadElement;
};

type Group = {
  readonly group:
    | string
    | {
        readonly name?: string;
        readonly path?: string;
        readonly children: ReadonlyArray<Group | Screen>;
        readonly props: {
          readonly screenOptions?: Record<string, unknown>;
        };
      };
};

type Navigator = {
  readonly navigator: string;
  readonly props?: {
    readonly options?: Record<string, unknown>;
  };
};

type ConfigNavigatorOptions = {
  readonly type?: 'stack' | 'native-stack' | 'bottom-tab';
  readonly name?: string;
  readonly children: ReadonlyArray<Group | Screen | Navigator>;
  readonly path?: string;
  readonly props?: Record<string, unknown>;
  readonly export?: boolean;
  readonly providers?: readonly string[];
  readonly passParams?: boolean;
  readonly lazy?: boolean;
};

type ConfigGroupOptions = Omit<ConfigNavigatorOptions, 'export' | 'type'>;

type Config = {
  readonly navigatorsImports: Record<string, string>;
  readonly routesImports: Record<string, string>;
  readonly navigators: Record<string, ConfigNavigatorOptions>;
  readonly groups: Record<string, ConfigGroupOptions>;
};

type ConfigElement = Screen | Group | Navigator;

type Common = {
  readonly parentNavigatorName: string;
  readonly screenName: string;
  readonly componentName: string;
  readonly routeLiteral: string;
  readonly routeName: string;
  readonly exportRouteName: string;
  readonly isParentNavigatorExported?: boolean;
  readonly options?: Record<string, unknown>;
  readonly providers?: readonly string[];
};

type ScreenElement = {
  readonly type: 'screen';
  readonly importPath: string;
  readonly routeParams?: any;
  readonly initialParams?: Record<string, unknown>;
  readonly lazy?: boolean;
} & Common;

type NavigatorElement = {
  readonly type: 'navigator';
} & Common;

type GroupElement = readonly [
  {
    readonly type: 'group';
    readonly props?: Record<string, unknown>;
  },
  Elements,
];

type Element = NavigatorElement | ScreenElement | GroupElement;
type Elements = readonly Element[];

// Take a file path and source code, format the source code using Prettier, and then write the formatted source code to the specified file.
const writeFile = async (file: string, source: string) => {
  const resolvedPath = path.resolve(file);
  const prettierConfig = await prettier.resolveConfig(resolvedPath);

  const content = await prettier.format(source, prettierConfig ?? {});
  return fs.writeFileSync(
    resolvedPath,
    `/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n/* eslint-disable @typescript-eslint/no-var-requires */\n// CAUTION: this file is automatically generated, do not edit it.\n${content}`,
    'utf-8',
  );
};

// Map a navigator type to its corresponding import specifier and import path.
const mapNavigatorImport = (type: ConfigNavigatorOptions['type']): readonly [string, string] => {
  switch (type) {
    case 'bottom-tab':
      return ['createBottomTabNavigator', '@react-navigation/bottom-tabs'];
    case 'stack':
      return ['createStackNavigator', '@react-navigation/stack'];
    default:
      return ['createNativeStackNavigator', '@react-navigation/native-stack'];
  }
};

// Generate a navigator name based on the provided name and navigator type.
const makeNavigatorName = (name: string, type: ConfigNavigatorOptions['type']) => {
  switch (type) {
    case 'bottom-tab':
      return `${name}BottomTab`;
    case 'stack':
      return `${name}Stack`;
    default:
      return `${name}NativeStack`;
  }
};

const toKebabCase = (str: string) => {
  return str.replace(/\B(?:([A-Z])(?=[a-z]))|(?:(?<=[a-z0-9])([A-Z]))/g, '-$1$2').toLowerCase();
};

const isConfigNavigator = (value: ConfigElement): value is Navigator => {
  return (
    // @ts-expect-error
    !G.isString(value) && G.isNotNullable(value.navigator)
  );
};

const isConfigGroup = (value: ConfigElement): value is Group => {
  return (
    // @ts-expect-error
    G.isNotNullable(value.group) && (G.isString(value.group) || G.isObject(value.group))
  );
};
const isGroup = (element: Element): element is GroupElement => {
  return G.isArray(element) && element[0].type === 'group';
};

const isScreen = (element: Element): element is ScreenElement => {
  return !isGroup(element) && element.type === 'screen';
};

const isNavigator = (element: Element): element is NavigatorElement => {
  return !isGroup(element) && element.type === 'navigator';
};

const cleanNavigatorName = S.replace('Navigator', '');

// Create an import declaration using provided specifiers and source path.
const makeImportDeclaration = (specifiers: string | readonly string[], source: string) => {
  const isNamespaceSpecifier = G.isString(specifiers);
  const specs = isNamespaceSpecifier ? [specifiers] : specifiers;
  const type = isNamespaceSpecifier ? 'importNamespaceSpecifier' : 'importSpecifier';
  return j.importDeclaration(
    specs.map((specifier) => {
      return j[type](j.identifier(specifier));
    }),
    j.stringLiteral(source),
  );
};

// Generate an import path from an array of path segments.
const makeImportPath = (xs: ReadonlyArray<string | undefined>) => {
  const isChunkUndefined = A.some(xs, G.isNullable);

  if (isChunkUndefined) {
    throw new Error('Path is missing!');
  }

  return A.join(xs, '/');
};

// Generate a component name.
const makeComponentName = (xs: ReadonlyArray<string>) => {
  return A.join(xs, '');
};

// Generate a route literal.
const makeRouteLiteral = (xs: ReadonlyArray<string | undefined>) => {
  const name = pipe(xs, A.filter(G.isNotNullable), A.join('/'), toKebabCase);
  return S.concat('/', name);
};

// Generate a route name to be used in navigator options.
const makeRouteName = (xs: ReadonlyArray<string>) => {
  return S.concat('route', A.join(xs, ''));
};

// Generates a route name to be used in navigation helpers.
const makeExportRouteName = (xs: ReadonlyArray<string>) => {
  return S.concat('to', A.join(xs, ''));
};

// Extract the first key-value pair from an object and return it as a tuple.
const extractObject = <T, K extends keyof any>(element: Record<K, T>) => {
  return pipe(element, D.toPairs, A.getUnsafe(0));
};

// Transform a JavaScript object into an object expression.
const transformToObjectExpression = (obj: Record<string, unknown>): ObjectExpression => {
  const objProperties = pipe(
    obj,
    D.toPairs,
    A.map(([prop, value]) => {
      if (G.isObject(value) && value.type && value.type === 'SpreadElement') {
        return value as unknown as SpreadElement;
      }

      return j.objectProperty(
        j.identifier(prop),
        G.isObject(value) ? transformToObjectExpression(value) : j.template.expression([value]),
      );
    }),
  );
  return j.objectExpression(objProperties as Writeable<typeof objProperties>);
};

// Create a prop value for a JSX attribute.
const makePropValue = (prop: unknown) => {
  if (
    G.isObject(prop) &&
    prop.type &&
    A.some(['MemberExpression', 'StringLiteral', 'ArrowFunctionExpression'], F.equals(prop.type))
  ) {
    return prop;
  }

  if (G.isObject(prop)) {
    return transformToObjectExpression(prop);
  }

  return j.template.expression([prop]);
};

// Generates JSX attributes object from props.
const makePropsObject = (obj: Record<string, unknown> | undefined) => {
  return pipe(
    O.fromNullable(obj),
    O.mapWithDefault([], (obj) => {
      const xs = pipe(
        obj,
        D.toPairs,
        A.keepMap((prop) => {
          const [key, value] = prop;

          if (G.isNotNullable(value)) {
            return O.Some(j.jsxAttribute(j.jsxIdentifier(key), j.jsxExpressionContainer(makePropValue(value))));
          }

          return O.None;
        }),
      );

      return xs as Writeable<typeof xs>;
    }),
    O.getWithDefault([] as JSXAttribute[]),
  );
};

// Recursively traverse the children of a navigator or group, generating elements for screens and navigators.
const traverseChildren = (
  children: ReadonlyArray<ConfigElement>,
  navigatorOptions: Omit<ConfigNavigatorOptions, 'children'> & {
    readonly name: string;
    readonly groupName?: string;
    readonly groupPath?: string;
  },
  config: Config,
): Elements => {
  const { path: navigatorPath, name: navigatorName, groupName, groupPath, lazy = true } = navigatorOptions;

  const parentImportPath = groupPath ?? navigatorPath;
  const parentModuleName = groupName ?? navigatorName;

  return A.reduce(children, [] as Elements, (acc, element) => {
    const isGroupElement = isConfigGroup(element);

    if (isGroupElement && G.isString(element.group)) {
      const group = config.groups[element.group];
      return group
        ? A.append(acc, [
            {
              type: 'group',
              props: group.props,
            },
            traverseChildren(
              group.children,
              {
                ...navigatorOptions,
                groupName: element.group,
                groupPath: group.path,
              },
              config,
            ),
          ])
        : acc;
    }

    if (isGroupElement && !G.isString(element.group)) {
      return A.append(acc, [
        {
          type: 'group',
          props: element.group.props,
        },
        traverseChildren(
          element.group.children,
          {
            ...navigatorOptions,
            groupName: element.group.name,
            groupPath:
              element.group.path ??
              (parentImportPath && element.group.name
                ? path.join(parentImportPath, `${element.group.name}Group`)
                : undefined),
          },
          config,
        ),
      ]);
    }

    if (isConfigNavigator(element)) {
      const chunks = [element.navigator, 'Navigator'];

      return A.append(acc, {
        type: 'navigator',
        screenName: element.navigator,
        routeLiteral: makeRouteLiteral([element.navigator]),
        routeName: makeRouteName(chunks),
        exportRouteName: makeExportRouteName(chunks),
        componentName: makeComponentName(chunks),
        parentNavigatorName: navigatorName,
        isParentNavigatorExported: navigatorOptions.export,
        options: element.props?.options,
      });
    }

    if (G.isString(element)) {
      const chunks = [parentModuleName, element];

      return A.append(acc, {
        type: 'screen',
        screenName: element,
        importPath: makeImportPath([parentImportPath, element]),
        componentName: makeComponentName(chunks),
        routeLiteral: makeRouteLiteral(chunks),
        routeName: makeRouteName(chunks),
        exportRouteName: makeExportRouteName(chunks),
        parentNavigatorName: navigatorName,
        isParentNavigatorExported: navigatorOptions.export,
        lazy,
      });
    }

    const [screenName, screenOptions] = extractObject(element as ScreenObject);
    const { path: screenPath, props } = screenOptions;

    const chunks = [parentModuleName, screenName];

    const importPath = screenPath ?? makeImportPath([parentImportPath, screenName]);
    const componentName = screenPath ? screenName : makeComponentName(chunks);
    const singleScreenChunks = props?.name ? [props.name] : chunks;

    return A.append(acc, {
      type: 'screen',
      screenName,
      importPath,
      componentName,
      routeLiteral: makeRouteLiteral(chunks),
      routeName: makeRouteName(singleScreenChunks),
      exportRouteName: makeExportRouteName(singleScreenChunks),
      routeParams: screenOptions.params,
      parentNavigatorName: navigatorName,
      isParentNavigatorExported: navigatorOptions.export,
      options: screenOptions.props?.options,
      lazy: screenOptions.lazy ?? lazy,
    });
  });
};

// Recursively traverse the navigation configuration tree, generating tuples containing navigator names and options, as well as their children.
const traverseNavigatorsTree = (config: Config) => {
  return pipe(
    config.navigators,
    D.toPairs,
    A.map(([navigatorName, navigatorOptions]) => {
      const { children, name, ...rest } = navigatorOptions;
      return [
        [cleanNavigatorName(navigatorName), navigatorOptions],
        traverseChildren(
          children,
          {
            name: cleanNavigatorName(name ?? navigatorName),
            ...rest,
          },
          config,
        ),
      ] as const;
    }),
  );
};

// Flatten the elements obtained from traversing the navigation configuration tree.
const flattenTreeElements = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  // @ts-expect-error
  return pipe(tree, A.deepFlat, A.filter(F.either(isNavigator, isScreen))) as readonly (
    | ScreenElement
    | NavigatorElement
  )[];
};

// Generate import declarations for React Navigation components based on the navigator types specified in the configuration.
const makeReactNavigationImports = (navigators: Config['navigators']) => {
  const xs = pipe(
    navigators,
    D.toPairs,
    A.map(([, navigatorOptions]) => {
      return mapNavigatorImport(navigatorOptions.type);
    }),
    A.uniq,
    A.map(([importSpecifier, importPath]) => {
      return makeImportDeclaration([importSpecifier], importPath);
    }),
  );

  return xs as Writeable<typeof xs>;
};

// Generate user-defined import declarations (see routesImports and navigatorsImports).
const makeUserImports = (imports: Record<string, string> | undefined) => {
  if (imports) {
    return pipe(
      imports,
      D.toPairs,
      A.groupBy(([_, importPath]) => {
        return importPath;
      }),
      D.toPairs,
      A.map(([importPath, imports]) => {
        return makeImportDeclaration(
          A.map(imports, ([importSpecifier]) => {
            return importSpecifier;
          }),
          importPath,
        );
      }),
    );
  }

  return undefined;
};

// Generate import declarations for screen components.
const makeScreenImports = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  const xs = pipe(
    tree,
    flattenTreeElements,
    A.filter(isScreen),
    A.filter((element) => !element.lazy),
    A.uniqBy((element) => element.importPath),
    A.map((element) => {
      return makeImportDeclaration([element.componentName], element.importPath);
    }),
  );

  return xs as Writeable<typeof xs>;
};

// Generate navigator variable declarations based on the navigator configurations.
const makeNavigatorDefinitions = (navigators: Config['navigators']) => {
  const xs = pipe(
    navigators,
    D.toPairs,
    A.map(([navigatorName, navigatorOptions]) => {
      const [callExpressionName] = mapNavigatorImport(navigatorOptions.type);
      const callExpression = j.callExpression(j.identifier(callExpressionName), []);
      const variable = j.variableDeclaration('const', [
        j.variableDeclarator(
          j.identifier(makeNavigatorName(cleanNavigatorName(navigatorName), navigatorOptions.type)),
          callExpression,
        ),
      ]);

      return variable;
    }),
  );

  return xs as Writeable<typeof xs>;
};

// Generate route variable declarations.
const makeRouteVariable = (element: ScreenElement | NavigatorElement) => {
  const { routeLiteral, routeName } = element;

  return j.exportNamedDeclaration(
    j.variableDeclaration('const', [j.variableDeclarator(j.identifier(routeName), j.stringLiteral(routeLiteral))]),
  );
};

// Generate all route variable declarations.
const makeRouteVariables = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  const xs = pipe(
    tree,
    flattenTreeElements,
    A.uniqBy((element) => element.routeName),
    A.map(makeRouteVariable),
  );

  return xs as Writeable<typeof xs>;
};

// Map a variable type to its corresponding TypeScript AST node.
const mapVariableType = (value: unknown) => {
  switch (value) {
    case 'boolean':
      return j.tsBooleanKeyword();
    case 'string':
      return j.tsStringKeyword();
    case 'number':
      return j.tsNumberKeyword();
    default:
      return j.tsTypeReference(j.identifier(value as string));
  }
};

// Generate route variable declarations with corresponding types (see Route).
const makeExportedRouteVariable = (element: ScreenElement | NavigatorElement) => {
  const { type, routeName, parentNavigatorName, exportRouteName } = element;

  const typeParameters = isScreen(element)
    ? pipe(
        O.fromNullable(element.routeParams),
        O.map((params) => {
          if (G.isObject(params)) {
            const xs = pipe(
              params,
              D.toPairs,
              A.map(([key, value]) => {
                const type = mapVariableType(value);
                const signature = j.tsPropertySignature(j.identifier(key as string), j.tsTypeAnnotation(type));
                signature.readonly = true;

                return signature;
              }),
            );

            return j.tsTypeLiteral(xs as Writeable<typeof xs>);
          }

          return mapVariableType(params);
        }),
        O.map((typeLiteral) => {
          return j.tsTypeParameterInstantiation([typeLiteral]);
        }),
        O.toNullable,
      )
    : null;

  const typeReference = j.tsTypeReference(j.identifier('Route'), typeParameters);

  const arrayElements = pipe(
    [
      type === 'navigator' || element.isParentNavigatorExported
        ? undefined
        : j.identifier(makeRouteName([parentNavigatorName, 'Navigator'])),
      j.identifier(routeName),
    ],
    A.filter(G.isNotNullable),
  );

  const arrayExpression = j.tsAsExpression(
    arrayElements.length === 1
      ? (arrayElements[0] as Identifier)
      : j.arrayExpression(arrayElements as Writeable<typeof arrayElements>),
    j.tsUnknownKeyword(),
  );

  const asExpression = j.tsAsExpression(arrayExpression, typeReference);

  const exportDeclaration = j.exportNamedDeclaration(
    j.variableDeclaration('const', [j.variableDeclarator(j.identifier(exportRouteName), asExpression)]),
  );

  return exportDeclaration;
};

// Generate all route variable declarations with types.
const makeExportedRouteVariables = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  const xs = pipe(
    tree,
    flattenTreeElements,
    A.uniqBy((element) => element.routeName),
    A.map(makeExportedRouteVariable),
  );

  return xs as Writeable<typeof xs>;
};

// Generates a route member expression for accessing route variables.
const makeRouteMemberExpression = (routeName: string) => {
  return j.memberExpression(j.identifier('route'), j.identifier(routeName));
};

// Generate JSX markup for screens.
// <StackNavigator.Screen {PROPS} />
const makeJSXScreen = (navigatorName: string, element: ScreenElement | NavigatorElement, params?: ScreenParams) => {
  const { routeName, componentName, options } = element;

  const initialParams: Record<string, unknown> = {
    ...params,
    meta: {
      presentation: options?.presentation ?? "'card'",
    },
  };

  const props: Record<string, unknown> = {
    options,
    name: makeRouteMemberExpression(routeName),
    initialParams,
  };

  if (isScreen(element)) {
    const { importPath, lazy } = element;

    if (lazy) {
      props.getComponent = j.arrowFunctionExpression(
        [],
        j.memberExpression(
          j.callExpression(j.identifier('require'), [j.literal(importPath)]),
          j.identifier(componentName),
        ),
      );
    } else {
      props.component = componentName;
    }
  } else {
    props.component = componentName;
  }

  const elementName = j.jsxMemberExpression(j.jsxIdentifier(navigatorName), j.jsxIdentifier('Screen'));
  const openingElement = j.jsxOpeningElement(elementName, makePropsObject(props));
  openingElement.selfClosing = true;

  return j.jsxElement(openingElement);
};

// Generate JSX markup for groups of screens.
// <Stack.Group {PROPS}>{CHILDREN}</Stack.Group>
const makeJSXGroup = (navigatorName: string, elements: Elements, props?: Record<string, unknown>): JSXElement => {
  const elementName = j.jsxMemberExpression(j.jsxIdentifier(navigatorName), j.jsxIdentifier('Group'));

  const openingElement = j.jsxOpeningElement(elementName, makePropsObject(props));
  const closingElement = j.jsxClosingElement(elementName);
  const children = A.map(elements, (element) => {
    if (isGroup(element)) {
      const [group, groupChildren] = element;
      return makeJSXGroup(navigatorName, groupChildren, group.props);
    }

    return makeJSXScreen(navigatorName, element);
  });

  return j.jsxElement(openingElement, closingElement, children as Writeable<typeof children>);
};

// Generate JSX markup for navigators.
// <Stack.Navigator {PROPS}>{CHILDREN -> GROUP/SCREEN}</Stack.Navigator>
const makeJSXNavigator = (navigator: readonly [string, ConfigNavigatorOptions], elements: Elements) => {
  const [navigatorName, navigatorOptions] = navigator;
  const { props, type, providers, passParams } = navigatorOptions;

  const name = makeNavigatorName(navigatorName, type);
  const elementName = j.jsxMemberExpression(j.jsxIdentifier(name), j.jsxIdentifier('Navigator'));

  const openingElement = j.jsxOpeningElement(elementName, makePropsObject(props));
  const closingElement = j.jsxClosingElement(elementName);

  const jsxChildren = A.mapWithIndex(elements, (index, element) => {
    if (isGroup(element)) {
      const [group, groupChildren] = element;
      return makeJSXGroup(name, groupChildren, group.props);
    }

    const params = {} as ScreenParams;

    if (index === 0 && passParams) {
      params.spreadElement = j.spreadElement(j.identifier('params'));
    }

    return makeJSXScreen(name, element, params);
  });

  const navigatorElement = j.jsxElement(openingElement, closingElement, jsxChildren as Writeable<typeof jsxChildren>);

  if (providers?.length) {
    return A.reduce(providers, navigatorElement, (acc, providerName) => {
      const identifier = j.jsxIdentifier(providerName);
      return j.jsxElement(j.jsxOpeningElement(identifier), j.jsxClosingElement(identifier), [acc]);
    });
  }

  return navigatorElement;
};

// Generate exported navigator variable declarations.
const makeExportedNavigator = (tuple: readonly [readonly [string, ConfigNavigatorOptions], Elements]) => {
  const [navigator, elements] = tuple;
  const [navigatorName, navigatorOptions] = navigator;
  const { passParams } = navigatorOptions;

  const propsParam = j.identifier('props');
  propsParam.typeAnnotation = j.tsTypeAnnotation(j.tsTypeReference(j.identifier('Params')));

  const property = j.property('init', j.identifier('params'), j.identifier('params'));
  property.shorthand = true;

  const arrowFunction = j.arrowFunctionExpression(
    [passParams ? propsParam : undefined].filter(G.isNotNullable),
    j.blockStatement(
      [
        passParams
          ? j.variableDeclaration('const', [j.variableDeclarator(j.objectPattern([property]), j.identifier('props'))])
          : undefined,
        j.returnStatement(makeJSXNavigator(navigator, elements)),
      ].filter(G.isNotNullable),
    ),
  );

  const variable = j.variableDeclaration('const', [
    j.variableDeclarator(j.identifier(`${navigatorName}Navigator`), arrowFunction),
  ]);

  return navigatorOptions.export ? j.exportNamedDeclaration(variable) : variable;
};

const makeParamsTypeDeclaration = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  const hasPassParams = A.some(tree, ([navigator]) => {
    const [, navigatorOptions] = navigator;
    return Boolean(navigatorOptions.passParams);
  });

  if (hasPassParams) {
    return j.tsTypeAliasDeclaration(
      j.identifier('Params'),
      j.tsTypeLiteral([
        j.tsPropertySignature(
          j.identifier('params'),
          j.tsTypeAnnotation(
            j.tsTypeReference(
              j.identifier('Record'),
              j.tsTypeParameterInstantiation([j.tsStringKeyword(), j.tsUnknownKeyword()]),
            ),
          ),
        ),
      ]),
    );
  }
};

// Generate all exported navigator variable declarations.
const makeExportedNavigators = (tree: ReturnType<typeof traverseNavigatorsTree>) => {
  const xs = pipe(tree, A.map(makeExportedNavigator));
  return xs as Writeable<typeof xs>;
};

const makeAllWithNavigatorsTree = (tree: ReturnType<typeof traverseNavigatorsTree>, fns: ReadonlyArray<any>) => {
  const xs = pipe(
    fns,
    A.reduce(A.makeEmpty<ASTNode>(), (acc, fn) => {
      return A.concat(acc, fn(tree));
    }),
  );

  return A.deepFlat(xs) as Writeable<typeof xs>;
};

// Generate the source code from the AST nodes.
const makeSource = (declarations: any) => {
  const xs = pipe(declarations, A.deepFlat, A.filter(G.isNotNullable));
  return j('')
    .find(j.Program)
    .replaceWith((_) => {
      return j.program(xs as any);
    })
    .toSource();
};

// The entry point of the script. It reads navigation configuration files (`.yaml`) using a recursive approach, processes them, generates route and navigator files.
const generate = async () => {
  const rootDir = path.resolve(__dirname, '..');
  const configFiles = await glob(path.join(rootDir, 'src', '**', 'navigation.config.yaml'));

  const generationProcess = configFiles.map((configFile) => {
    const dirname = path.dirname(configFile);
    const routesFile = path.join(dirname, 'routes.ts');
    const navigatorsFile = path.join(dirname, 'navigators.tsx');

    const config: Config = D.merge(
      {
        navigatorsImports: {},
        routesImports: {},
        navigators: {},
        groups: {},
      },
      YAML.load(configFile),
    );

    const navigatorsTree = traverseNavigatorsTree(config);

    const routes = makeSource([
      makeUserImports(config.routesImports),
      makeAllWithNavigatorsTree(navigatorsTree, [makeRouteVariables, makeExportedRouteVariables]),
    ]);

    const navigators = makeSource([
      makeImportDeclaration('React', 'react'),
      makeImportDeclaration('route', './routes'),
      makeReactNavigationImports(config.navigators),
      makeUserImports(config.navigatorsImports),
      makeParamsTypeDeclaration(navigatorsTree),
      makeNavigatorDefinitions(config.navigators),
      makeAllWithNavigatorsTree(navigatorsTree, [makeScreenImports, makeExportedNavigators]),
    ]);

    return Promise.all([writeFile(routesFile, routes), writeFile(navigatorsFile, navigators)]);
  });

  await Promise.all(generationProcess);
};

generate();
